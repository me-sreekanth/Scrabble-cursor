{"id":"7f2617e758d6621e2e497d412521dfd7","_format":"hh-sol-build-info-1","solcVersion":"0.8.20","solcLongVersion":"0.8.20+commit.a1b79de6","input":{"language":"Solidity","sources":{"@openzeppelin/contracts/utils/cryptography/Hashes.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/Hashes.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library of standard hash functions.\n *\n * _Available since v5.1._\n */\nlibrary Hashes {\n    /**\n     * @dev Commutative Keccak256 hash of a sorted pair of bytes32. Frequently used when working with merkle proofs.\n     *\n     * NOTE: Equivalent to the `standardNodeHash` in our https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n     */\n    function commutativeKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32) {\n        return a < b ? efficientKeccak256(a, b) : efficientKeccak256(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\n     */\n    function efficientKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32 value) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"},"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/MerkleProof.sol)\n// This file was procedurally generated from scripts/generate/templates/MerkleProof.js.\n\npragma solidity ^0.8.20;\n\nimport {Hashes} from \"./Hashes.sol\";\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the Merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\n * against this attack out of the box.\n *\n * IMPORTANT: Consider memory side-effects when using custom hashing functions\n * that access memory in an unsafe way.\n *\n * NOTE: This library supports proof verification for merkle trees built using\n * custom _commutative_ hashing functions (i.e. `H(a, b) == H(b, a)`). Proving\n * leaf inclusion in trees built using non-commutative hashing functions requires\n * additional logic that is not supported by this library.\n */\nlibrary MerkleProof {\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with the default hashing function.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with the default hashing function.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with a custom hashing function.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processProof(proof, leaf, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with a custom hashing function.\n     */\n    function processProof(\n        bytes32[] memory proof,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = hasher(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with the default hashing function.\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with the default hashing function.\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with a custom hashing function.\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processProofCalldata(proof, leaf, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with a custom hashing function.\n     */\n    function processProofCalldata(\n        bytes32[] calldata proof,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = hasher(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in memory with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProof}.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in memory with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in memory with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProof}.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in memory with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = hasher(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in calldata with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProofCalldata}.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in calldata with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in calldata with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProofCalldata}.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in calldata with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = hasher(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n}\n"},"contracts/Scrabble.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\ncontract Scrabble {\n  bytes32 public merkleRoot;\n\n  constructor() {\n    // Initial merkleRoot can be set here or later with setMerkleRoot\n    merkleRoot = 0x0000000000000000000000000000000000000000000000000000000000000000;\n  }\n\n  function setMerkleRoot(bytes32 _merkleRoot) external {\n    merkleRoot = _merkleRoot;\n  }\n\n  function verifyWord(bytes32 leaf, bytes32[] calldata proof) external view returns (bool) {\n    return MerkleProof.verify(proof, merkleRoot, leaf);\n  }\n}"}},"settings":{"viaIR":true,"optimizer":{"enabled":true,"runs":200},"evmVersion":"paris","outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata","devdoc","userdoc","storageLayout","evm.gasEstimates"],"":["ast"]}},"metadata":{"useLiteralContent":true}}},"output":{"sources":{"@openzeppelin/contracts/utils/cryptography/Hashes.sol":{"ast":{"absolutePath":"@openzeppelin/contracts/utils/cryptography/Hashes.sol","exportedSymbols":{"Hashes":[39]},"id":40,"license":"MIT","nodeType":"SourceUnit","nodes":[{"id":1,"literals":["solidity","^","0.8",".20"],"nodeType":"PragmaDirective","src":"113:24:0"},{"abstract":false,"baseContracts":[],"canonicalName":"Hashes","contractDependencies":[],"contractKind":"library","documentation":{"id":2,"nodeType":"StructuredDocumentation","src":"139:81:0","text":" @dev Library of standard hash functions.\n _Available since v5.1._"},"fullyImplemented":true,"id":39,"linearizedBaseContracts":[39],"name":"Hashes","nameLocation":"229:6:0","nodeType":"ContractDefinition","nodes":[{"body":{"id":25,"nodeType":"Block","src":"588:83:0","statements":[{"expression":{"condition":{"commonType":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"id":14,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":12,"name":"a","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":5,"src":"605:1:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"id":13,"name":"b","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":7,"src":"609:1:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"605:5:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseExpression":{"arguments":[{"id":20,"name":"b","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":7,"src":"659:1:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"id":21,"name":"a","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":5,"src":"662:1:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"id":19,"name":"efficientKeccak256","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":38,"src":"640:18:0","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) pure returns (bytes32)"}},"id":22,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"640:24:0","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":23,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"Conditional","src":"605:59:0","trueExpression":{"arguments":[{"id":16,"name":"a","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":5,"src":"632:1:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"id":17,"name":"b","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":7,"src":"635:1:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"id":15,"name":"efficientKeccak256","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":38,"src":"613:18:0","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) pure returns (bytes32)"}},"id":18,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"613:24:0","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":11,"id":24,"nodeType":"Return","src":"598:66:0"}]},"documentation":{"id":3,"nodeType":"StructuredDocumentation","src":"242:257:0","text":" @dev Commutative Keccak256 hash of a sorted pair of bytes32. Frequently used when working with merkle proofs.\n NOTE: Equivalent to the `standardNodeHash` in our https://github.com/OpenZeppelin/merkle-tree[JavaScript library]."},"id":26,"implemented":true,"kind":"function","modifiers":[],"name":"commutativeKeccak256","nameLocation":"513:20:0","nodeType":"FunctionDefinition","parameters":{"id":8,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5,"mutability":"mutable","name":"a","nameLocation":"542:1:0","nodeType":"VariableDeclaration","scope":26,"src":"534:9:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":4,"name":"bytes32","nodeType":"ElementaryTypeName","src":"534:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":7,"mutability":"mutable","name":"b","nameLocation":"553:1:0","nodeType":"VariableDeclaration","scope":26,"src":"545:9:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":6,"name":"bytes32","nodeType":"ElementaryTypeName","src":"545:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"533:22:0"},"returnParameters":{"id":11,"nodeType":"ParameterList","parameters":[{"constant":false,"id":10,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":26,"src":"579:7:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":9,"name":"bytes32","nodeType":"ElementaryTypeName","src":"579:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"578:9:0"},"scope":39,"src":"504:167:0","stateMutability":"pure","virtual":false,"visibility":"internal"},{"body":{"id":37,"nodeType":"Block","src":"879:151:0","statements":[{"AST":{"nodeType":"YulBlock","src":"914:110:0","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"935:4:0","type":"","value":"0x00"},{"name":"a","nodeType":"YulIdentifier","src":"941:1:0"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"928:6:0"},"nodeType":"YulFunctionCall","src":"928:15:0"},"nodeType":"YulExpressionStatement","src":"928:15:0"},{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"963:4:0","type":"","value":"0x20"},{"name":"b","nodeType":"YulIdentifier","src":"969:1:0"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"956:6:0"},"nodeType":"YulFunctionCall","src":"956:15:0"},"nodeType":"YulExpressionStatement","src":"956:15:0"},{"nodeType":"YulAssignment","src":"984:30:0","value":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1003:4:0","type":"","value":"0x00"},{"kind":"number","nodeType":"YulLiteral","src":"1009:4:0","type":"","value":"0x40"}],"functionName":{"name":"keccak256","nodeType":"YulIdentifier","src":"993:9:0"},"nodeType":"YulFunctionCall","src":"993:21:0"},"variableNames":[{"name":"value","nodeType":"YulIdentifier","src":"984:5:0"}]}]},"evmVersion":"paris","externalReferences":[{"declaration":29,"isOffset":false,"isSlot":false,"src":"941:1:0","valueSize":1},{"declaration":31,"isOffset":false,"isSlot":false,"src":"969:1:0","valueSize":1},{"declaration":34,"isOffset":false,"isSlot":false,"src":"984:5:0","valueSize":1}],"flags":["memory-safe"],"id":36,"nodeType":"InlineAssembly","src":"889:135:0"}]},"documentation":{"id":27,"nodeType":"StructuredDocumentation","src":"677:109:0","text":" @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory."},"id":38,"implemented":true,"kind":"function","modifiers":[],"name":"efficientKeccak256","nameLocation":"800:18:0","nodeType":"FunctionDefinition","parameters":{"id":32,"nodeType":"ParameterList","parameters":[{"constant":false,"id":29,"mutability":"mutable","name":"a","nameLocation":"827:1:0","nodeType":"VariableDeclaration","scope":38,"src":"819:9:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":28,"name":"bytes32","nodeType":"ElementaryTypeName","src":"819:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":31,"mutability":"mutable","name":"b","nameLocation":"838:1:0","nodeType":"VariableDeclaration","scope":38,"src":"830:9:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":30,"name":"bytes32","nodeType":"ElementaryTypeName","src":"830:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"818:22:0"},"returnParameters":{"id":35,"nodeType":"ParameterList","parameters":[{"constant":false,"id":34,"mutability":"mutable","name":"value","nameLocation":"872:5:0","nodeType":"VariableDeclaration","scope":38,"src":"864:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":33,"name":"bytes32","nodeType":"ElementaryTypeName","src":"864:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"863:15:0"},"scope":39,"src":"791:239:0","stateMutability":"pure","virtual":false,"visibility":"internal"}],"scope":40,"src":"221:811:0","usedErrors":[],"usedEvents":[]}],"src":"113:920:0"},"id":0},"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol":{"ast":{"absolutePath":"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol","exportedSymbols":{"Hashes":[39],"MerkleProof":[1112]},"id":1113,"license":"MIT","nodeType":"SourceUnit","nodes":[{"id":41,"literals":["solidity","^","0.8",".20"],"nodeType":"PragmaDirective","src":"206:24:1"},{"absolutePath":"@openzeppelin/contracts/utils/cryptography/Hashes.sol","file":"./Hashes.sol","id":43,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":1113,"sourceUnit":40,"src":"232:36:1","symbolAliases":[{"foreign":{"id":42,"name":"Hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":39,"src":"240:6:1","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"abstract":false,"baseContracts":[],"canonicalName":"MerkleProof","contractDependencies":[],"contractKind":"library","documentation":{"id":44,"nodeType":"StructuredDocumentation","src":"270:1082:1","text":" @dev These functions deal with verification of Merkle Tree proofs.\n The tree and the proofs can be generated using our\n https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n You will find a quickstart guide in the readme.\n WARNING: You should avoid using leaf values that are 64 bytes long prior to\n hashing, or use a hash function other than keccak256 for hashing leaves.\n This is because the concatenation of a sorted pair of internal nodes in\n the Merkle tree could be reinterpreted as a leaf value.\n OpenZeppelin's JavaScript library generates Merkle trees that are safe\n against this attack out of the box.\n IMPORTANT: Consider memory side-effects when using custom hashing functions\n that access memory in an unsafe way.\n NOTE: This library supports proof verification for merkle trees built using\n custom _commutative_ hashing functions (i.e. `H(a, b) == H(b, a)`). Proving\n leaf inclusion in trees built using non-commutative hashing functions requires\n additional logic that is not supported by this library."},"fullyImplemented":true,"id":1112,"linearizedBaseContracts":[1112],"name":"MerkleProof","nameLocation":"1361:11:1","nodeType":"ContractDefinition","nodes":[{"documentation":{"id":45,"nodeType":"StructuredDocumentation","src":"1379:60:1","text":"@dev The multiproof provided is not valid."},"errorSelector":"35140492","id":47,"name":"MerkleProofInvalidMultiproof","nameLocation":"1450:28:1","nodeType":"ErrorDefinition","parameters":{"id":46,"nodeType":"ParameterList","parameters":[],"src":"1478:2:1"},"src":"1444:37:1"},{"body":{"id":67,"nodeType":"Block","src":"1999:57:1","statements":[{"expression":{"commonType":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"id":65,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"arguments":[{"id":61,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":51,"src":"2029:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},{"id":62,"name":"leaf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":55,"src":"2036:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"id":60,"name":"processProof","nodeType":"Identifier","overloadedDeclarations":[109,191],"referencedDeclaration":109,"src":"2016:12:1","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_array$_t_bytes32_$dyn_memory_ptr_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32[] memory,bytes32) pure returns (bytes32)"}},"id":63,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2016:25:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"id":64,"name":"root","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":53,"src":"2045:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"2016:33:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"functionReturnParameters":59,"id":66,"nodeType":"Return","src":"2009:40:1"}]},"documentation":{"id":48,"nodeType":"StructuredDocumentation","src":"1487:410:1","text":" @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n defined by `root`. For this, a `proof` must be provided, containing\n sibling hashes on the branch from the leaf to the root of the tree. Each\n pair of leaves and each pair of pre-images are assumed to be sorted.\n This version handles proofs in memory with the default hashing function."},"id":68,"implemented":true,"kind":"function","modifiers":[],"name":"verify","nameLocation":"1911:6:1","nodeType":"FunctionDefinition","parameters":{"id":56,"nodeType":"ParameterList","parameters":[{"constant":false,"id":51,"mutability":"mutable","name":"proof","nameLocation":"1935:5:1","nodeType":"VariableDeclaration","scope":68,"src":"1918:22:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":49,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1918:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":50,"nodeType":"ArrayTypeName","src":"1918:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":53,"mutability":"mutable","name":"root","nameLocation":"1950:4:1","nodeType":"VariableDeclaration","scope":68,"src":"1942:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":52,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1942:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":55,"mutability":"mutable","name":"leaf","nameLocation":"1964:4:1","nodeType":"VariableDeclaration","scope":68,"src":"1956:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":54,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1956:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"1917:52:1"},"returnParameters":{"id":59,"nodeType":"ParameterList","parameters":[{"constant":false,"id":58,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":68,"src":"1993:4:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":57,"name":"bool","nodeType":"ElementaryTypeName","src":"1993:4:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"1992:6:1"},"scope":1112,"src":"1902:154:1","stateMutability":"pure","virtual":false,"visibility":"internal"},{"body":{"id":108,"nodeType":"Block","src":"2549:216:1","statements":[{"assignments":[80],"declarations":[{"constant":false,"id":80,"mutability":"mutable","name":"computedHash","nameLocation":"2567:12:1","nodeType":"VariableDeclaration","scope":108,"src":"2559:20:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":79,"name":"bytes32","nodeType":"ElementaryTypeName","src":"2559:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"id":82,"initialValue":{"id":81,"name":"leaf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":74,"src":"2582:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"2559:27:1"},{"body":{"id":104,"nodeType":"Block","src":"2639:91:1","statements":[{"expression":{"id":102,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":94,"name":"computedHash","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":80,"src":"2653:12:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"id":97,"name":"computedHash","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":80,"src":"2696:12:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"baseExpression":{"id":98,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":72,"src":"2710:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":100,"indexExpression":{"id":99,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":84,"src":"2716:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"2710:8:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"expression":{"id":95,"name":"Hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":39,"src":"2668:6:1","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Hashes_$39_$","typeString":"type(library Hashes)"}},"id":96,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"2675:20:1","memberName":"commutativeKeccak256","nodeType":"MemberAccess","referencedDeclaration":26,"src":"2668:27:1","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) pure returns (bytes32)"}},"id":101,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2668:51:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"2653:66:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":103,"nodeType":"ExpressionStatement","src":"2653:66:1"}]},"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":90,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":87,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":84,"src":"2616:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"expression":{"id":88,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":72,"src":"2620:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":89,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"2626:6:1","memberName":"length","nodeType":"MemberAccess","src":"2620:12:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"2616:16:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":105,"initializationExpression":{"assignments":[84],"declarations":[{"constant":false,"id":84,"mutability":"mutable","name":"i","nameLocation":"2609:1:1","nodeType":"VariableDeclaration","scope":105,"src":"2601:9:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":83,"name":"uint256","nodeType":"ElementaryTypeName","src":"2601:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":86,"initialValue":{"hexValue":"30","id":85,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"2613:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"2601:13:1"},"loopExpression":{"expression":{"id":92,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"2634:3:1","subExpression":{"id":91,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":84,"src":"2634:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":93,"nodeType":"ExpressionStatement","src":"2634:3:1"},"nodeType":"ForStatement","src":"2596:134:1"},{"expression":{"id":106,"name":"computedHash","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":80,"src":"2746:12:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":78,"id":107,"nodeType":"Return","src":"2739:19:1"}]},"documentation":{"id":69,"nodeType":"StructuredDocumentation","src":"2062:390:1","text":" @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n hash matches the root of the tree. When processing the proof, the pairs\n of leaves & pre-images are assumed to be sorted.\n This version handles proofs in memory with the default hashing function."},"id":109,"implemented":true,"kind":"function","modifiers":[],"name":"processProof","nameLocation":"2466:12:1","nodeType":"FunctionDefinition","parameters":{"id":75,"nodeType":"ParameterList","parameters":[{"constant":false,"id":72,"mutability":"mutable","name":"proof","nameLocation":"2496:5:1","nodeType":"VariableDeclaration","scope":109,"src":"2479:22:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":70,"name":"bytes32","nodeType":"ElementaryTypeName","src":"2479:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":71,"nodeType":"ArrayTypeName","src":"2479:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":74,"mutability":"mutable","name":"leaf","nameLocation":"2511:4:1","nodeType":"VariableDeclaration","scope":109,"src":"2503:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":73,"name":"bytes32","nodeType":"ElementaryTypeName","src":"2503:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"2478:38:1"},"returnParameters":{"id":78,"nodeType":"ParameterList","parameters":[{"constant":false,"id":77,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":109,"src":"2540:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":76,"name":"bytes32","nodeType":"ElementaryTypeName","src":"2540:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"2539:9:1"},"scope":1112,"src":"2457:308:1","stateMutability":"pure","virtual":false,"visibility":"internal"},{"body":{"id":140,"nodeType":"Block","src":"3376:65:1","statements":[{"expression":{"commonType":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"id":138,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"arguments":[{"id":133,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":113,"src":"3406:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},{"id":134,"name":"leaf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":117,"src":"3413:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"id":135,"name":"hasher","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":127,"src":"3419:6:1","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"}],"id":132,"name":"processProof","nodeType":"Identifier","overloadedDeclarations":[109,191],"referencedDeclaration":191,"src":"3393:12:1","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_array$_t_bytes32_$dyn_memory_ptr_$_t_bytes32_$_t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$_$returns$_t_bytes32_$","typeString":"function (bytes32[] memory,bytes32,function (bytes32,bytes32) view returns (bytes32)) view returns (bytes32)"}},"id":136,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3393:33:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"id":137,"name":"root","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":115,"src":"3430:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"3393:41:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"functionReturnParameters":131,"id":139,"nodeType":"Return","src":"3386:48:1"}]},"documentation":{"id":110,"nodeType":"StructuredDocumentation","src":"2771:407:1","text":" @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n defined by `root`. For this, a `proof` must be provided, containing\n sibling hashes on the branch from the leaf to the root of the tree. Each\n pair of leaves and each pair of pre-images are assumed to be sorted.\n This version handles proofs in memory with a custom hashing function."},"id":141,"implemented":true,"kind":"function","modifiers":[],"name":"verify","nameLocation":"3192:6:1","nodeType":"FunctionDefinition","parameters":{"id":128,"nodeType":"ParameterList","parameters":[{"constant":false,"id":113,"mutability":"mutable","name":"proof","nameLocation":"3225:5:1","nodeType":"VariableDeclaration","scope":141,"src":"3208:22:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":111,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3208:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":112,"nodeType":"ArrayTypeName","src":"3208:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":115,"mutability":"mutable","name":"root","nameLocation":"3248:4:1","nodeType":"VariableDeclaration","scope":141,"src":"3240:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":114,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3240:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":117,"mutability":"mutable","name":"leaf","nameLocation":"3270:4:1","nodeType":"VariableDeclaration","scope":141,"src":"3262:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":116,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3262:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":127,"mutability":"mutable","name":"hasher","nameLocation":"3334:6:1","nodeType":"VariableDeclaration","scope":141,"src":"3284:56:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"},"typeName":{"id":126,"nodeType":"FunctionTypeName","parameterTypes":{"id":122,"nodeType":"ParameterList","parameters":[{"constant":false,"id":119,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":126,"src":"3293:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":118,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3293:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":121,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":126,"src":"3302:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":120,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3302:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"3292:18:1"},"returnParameterTypes":{"id":125,"nodeType":"ParameterList","parameters":[{"constant":false,"id":124,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":126,"src":"3325:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":123,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3325:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"3324:9:1"},"src":"3284:56:1","stateMutability":"view","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"},"visibility":"internal"},"visibility":"internal"}],"src":"3198:148:1"},"returnParameters":{"id":131,"nodeType":"ParameterList","parameters":[{"constant":false,"id":130,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":141,"src":"3370:4:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":129,"name":"bool","nodeType":"ElementaryTypeName","src":"3370:4:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"3369:6:1"},"scope":1112,"src":"3183:258:1","stateMutability":"view","virtual":false,"visibility":"internal"},{"body":{"id":190,"nodeType":"Block","src":"4019:195:1","statements":[{"assignments":[163],"declarations":[{"constant":false,"id":163,"mutability":"mutable","name":"computedHash","nameLocation":"4037:12:1","nodeType":"VariableDeclaration","scope":190,"src":"4029:20:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":162,"name":"bytes32","nodeType":"ElementaryTypeName","src":"4029:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"id":165,"initialValue":{"id":164,"name":"leaf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":147,"src":"4052:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"4029:27:1"},{"body":{"id":186,"nodeType":"Block","src":"4109:70:1","statements":[{"expression":{"id":184,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":177,"name":"computedHash","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":163,"src":"4123:12:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"id":179,"name":"computedHash","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":163,"src":"4145:12:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"baseExpression":{"id":180,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":145,"src":"4159:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":182,"indexExpression":{"id":181,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":167,"src":"4165:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"4159:8:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"id":178,"name":"hasher","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":157,"src":"4138:6:1","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"}},"id":183,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4138:30:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"4123:45:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":185,"nodeType":"ExpressionStatement","src":"4123:45:1"}]},"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":173,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":170,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":167,"src":"4086:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"expression":{"id":171,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":145,"src":"4090:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":172,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"4096:6:1","memberName":"length","nodeType":"MemberAccess","src":"4090:12:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"4086:16:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":187,"initializationExpression":{"assignments":[167],"declarations":[{"constant":false,"id":167,"mutability":"mutable","name":"i","nameLocation":"4079:1:1","nodeType":"VariableDeclaration","scope":187,"src":"4071:9:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":166,"name":"uint256","nodeType":"ElementaryTypeName","src":"4071:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":169,"initialValue":{"hexValue":"30","id":168,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"4083:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"4071:13:1"},"loopExpression":{"expression":{"id":175,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"4104:3:1","subExpression":{"id":174,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":167,"src":"4104:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":176,"nodeType":"ExpressionStatement","src":"4104:3:1"},"nodeType":"ForStatement","src":"4066:113:1"},{"expression":{"id":188,"name":"computedHash","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":163,"src":"4195:12:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":161,"id":189,"nodeType":"Return","src":"4188:19:1"}]},"documentation":{"id":142,"nodeType":"StructuredDocumentation","src":"3447:387:1","text":" @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n hash matches the root of the tree. When processing the proof, the pairs\n of leaves & pre-images are assumed to be sorted.\n This version handles proofs in memory with a custom hashing function."},"id":191,"implemented":true,"kind":"function","modifiers":[],"name":"processProof","nameLocation":"3848:12:1","nodeType":"FunctionDefinition","parameters":{"id":158,"nodeType":"ParameterList","parameters":[{"constant":false,"id":145,"mutability":"mutable","name":"proof","nameLocation":"3887:5:1","nodeType":"VariableDeclaration","scope":191,"src":"3870:22:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":143,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3870:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":144,"nodeType":"ArrayTypeName","src":"3870:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":147,"mutability":"mutable","name":"leaf","nameLocation":"3910:4:1","nodeType":"VariableDeclaration","scope":191,"src":"3902:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":146,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3902:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":157,"mutability":"mutable","name":"hasher","nameLocation":"3974:6:1","nodeType":"VariableDeclaration","scope":191,"src":"3924:56:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"},"typeName":{"id":156,"nodeType":"FunctionTypeName","parameterTypes":{"id":152,"nodeType":"ParameterList","parameters":[{"constant":false,"id":149,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":156,"src":"3933:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":148,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3933:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":151,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":156,"src":"3942:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":150,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3942:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"3932:18:1"},"returnParameterTypes":{"id":155,"nodeType":"ParameterList","parameters":[{"constant":false,"id":154,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":156,"src":"3965:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":153,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3965:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"3964:9:1"},"src":"3924:56:1","stateMutability":"view","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"},"visibility":"internal"},"visibility":"internal"}],"src":"3860:126:1"},"returnParameters":{"id":161,"nodeType":"ParameterList","parameters":[{"constant":false,"id":160,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":191,"src":"4010:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":159,"name":"bytes32","nodeType":"ElementaryTypeName","src":"4010:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"4009:9:1"},"scope":1112,"src":"3839:375:1","stateMutability":"view","virtual":false,"visibility":"internal"},{"body":{"id":211,"nodeType":"Block","src":"4744:65:1","statements":[{"expression":{"commonType":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"id":209,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"arguments":[{"id":205,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":195,"src":"4782:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},{"id":206,"name":"leaf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":199,"src":"4789:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"id":204,"name":"processProofCalldata","nodeType":"Identifier","overloadedDeclarations":[253,335],"referencedDeclaration":253,"src":"4761:20:1","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_array$_t_bytes32_$dyn_calldata_ptr_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32[] calldata,bytes32) pure returns (bytes32)"}},"id":207,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4761:33:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"id":208,"name":"root","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":197,"src":"4798:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"4761:41:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"functionReturnParameters":203,"id":210,"nodeType":"Return","src":"4754:48:1"}]},"documentation":{"id":192,"nodeType":"StructuredDocumentation","src":"4220:412:1","text":" @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n defined by `root`. For this, a `proof` must be provided, containing\n sibling hashes on the branch from the leaf to the root of the tree. Each\n pair of leaves and each pair of pre-images are assumed to be sorted.\n This version handles proofs in calldata with the default hashing function."},"id":212,"implemented":true,"kind":"function","modifiers":[],"name":"verifyCalldata","nameLocation":"4646:14:1","nodeType":"FunctionDefinition","parameters":{"id":200,"nodeType":"ParameterList","parameters":[{"constant":false,"id":195,"mutability":"mutable","name":"proof","nameLocation":"4680:5:1","nodeType":"VariableDeclaration","scope":212,"src":"4661:24:1","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":193,"name":"bytes32","nodeType":"ElementaryTypeName","src":"4661:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":194,"nodeType":"ArrayTypeName","src":"4661:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":197,"mutability":"mutable","name":"root","nameLocation":"4695:4:1","nodeType":"VariableDeclaration","scope":212,"src":"4687:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":196,"name":"bytes32","nodeType":"ElementaryTypeName","src":"4687:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":199,"mutability":"mutable","name":"leaf","nameLocation":"4709:4:1","nodeType":"VariableDeclaration","scope":212,"src":"4701:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":198,"name":"bytes32","nodeType":"ElementaryTypeName","src":"4701:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"4660:54:1"},"returnParameters":{"id":203,"nodeType":"ParameterList","parameters":[{"constant":false,"id":202,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":212,"src":"4738:4:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":201,"name":"bool","nodeType":"ElementaryTypeName","src":"4738:4:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"4737:6:1"},"scope":1112,"src":"4637:172:1","stateMutability":"pure","virtual":false,"visibility":"internal"},{"body":{"id":252,"nodeType":"Block","src":"5314:216:1","statements":[{"assignments":[224],"declarations":[{"constant":false,"id":224,"mutability":"mutable","name":"computedHash","nameLocation":"5332:12:1","nodeType":"VariableDeclaration","scope":252,"src":"5324:20:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":223,"name":"bytes32","nodeType":"ElementaryTypeName","src":"5324:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"id":226,"initialValue":{"id":225,"name":"leaf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":218,"src":"5347:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"5324:27:1"},{"body":{"id":248,"nodeType":"Block","src":"5404:91:1","statements":[{"expression":{"id":246,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":238,"name":"computedHash","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":224,"src":"5418:12:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"id":241,"name":"computedHash","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":224,"src":"5461:12:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"baseExpression":{"id":242,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":216,"src":"5475:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},"id":244,"indexExpression":{"id":243,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":228,"src":"5481:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"5475:8:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"expression":{"id":239,"name":"Hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":39,"src":"5433:6:1","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Hashes_$39_$","typeString":"type(library Hashes)"}},"id":240,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"5440:20:1","memberName":"commutativeKeccak256","nodeType":"MemberAccess","referencedDeclaration":26,"src":"5433:27:1","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) pure returns (bytes32)"}},"id":245,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5433:51:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"5418:66:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":247,"nodeType":"ExpressionStatement","src":"5418:66:1"}]},"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":234,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":231,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":228,"src":"5381:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"expression":{"id":232,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":216,"src":"5385:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},"id":233,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"5391:6:1","memberName":"length","nodeType":"MemberAccess","src":"5385:12:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"5381:16:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":249,"initializationExpression":{"assignments":[228],"declarations":[{"constant":false,"id":228,"mutability":"mutable","name":"i","nameLocation":"5374:1:1","nodeType":"VariableDeclaration","scope":249,"src":"5366:9:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":227,"name":"uint256","nodeType":"ElementaryTypeName","src":"5366:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":230,"initialValue":{"hexValue":"30","id":229,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"5378:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"5366:13:1"},"loopExpression":{"expression":{"id":236,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"5399:3:1","subExpression":{"id":235,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":228,"src":"5399:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":237,"nodeType":"ExpressionStatement","src":"5399:3:1"},"nodeType":"ForStatement","src":"5361:134:1"},{"expression":{"id":250,"name":"computedHash","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":224,"src":"5511:12:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":222,"id":251,"nodeType":"Return","src":"5504:19:1"}]},"documentation":{"id":213,"nodeType":"StructuredDocumentation","src":"4815:392:1","text":" @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n hash matches the root of the tree. When processing the proof, the pairs\n of leaves & pre-images are assumed to be sorted.\n This version handles proofs in calldata with the default hashing function."},"id":253,"implemented":true,"kind":"function","modifiers":[],"name":"processProofCalldata","nameLocation":"5221:20:1","nodeType":"FunctionDefinition","parameters":{"id":219,"nodeType":"ParameterList","parameters":[{"constant":false,"id":216,"mutability":"mutable","name":"proof","nameLocation":"5261:5:1","nodeType":"VariableDeclaration","scope":253,"src":"5242:24:1","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":214,"name":"bytes32","nodeType":"ElementaryTypeName","src":"5242:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":215,"nodeType":"ArrayTypeName","src":"5242:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":218,"mutability":"mutable","name":"leaf","nameLocation":"5276:4:1","nodeType":"VariableDeclaration","scope":253,"src":"5268:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":217,"name":"bytes32","nodeType":"ElementaryTypeName","src":"5268:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"5241:40:1"},"returnParameters":{"id":222,"nodeType":"ParameterList","parameters":[{"constant":false,"id":221,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":253,"src":"5305:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":220,"name":"bytes32","nodeType":"ElementaryTypeName","src":"5305:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"5304:9:1"},"scope":1112,"src":"5212:318:1","stateMutability":"pure","virtual":false,"visibility":"internal"},{"body":{"id":284,"nodeType":"Block","src":"6153:73:1","statements":[{"expression":{"commonType":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"id":282,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"arguments":[{"id":277,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":257,"src":"6191:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},{"id":278,"name":"leaf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":261,"src":"6198:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"id":279,"name":"hasher","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":271,"src":"6204:6:1","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"}],"id":276,"name":"processProofCalldata","nodeType":"Identifier","overloadedDeclarations":[253,335],"referencedDeclaration":335,"src":"6170:20:1","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_array$_t_bytes32_$dyn_calldata_ptr_$_t_bytes32_$_t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$_$returns$_t_bytes32_$","typeString":"function (bytes32[] calldata,bytes32,function (bytes32,bytes32) view returns (bytes32)) view returns (bytes32)"}},"id":280,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6170:41:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"id":281,"name":"root","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":259,"src":"6215:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"6170:49:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"functionReturnParameters":275,"id":283,"nodeType":"Return","src":"6163:56:1"}]},"documentation":{"id":254,"nodeType":"StructuredDocumentation","src":"5536:409:1","text":" @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n defined by `root`. For this, a `proof` must be provided, containing\n sibling hashes on the branch from the leaf to the root of the tree. Each\n pair of leaves and each pair of pre-images are assumed to be sorted.\n This version handles proofs in calldata with a custom hashing function."},"id":285,"implemented":true,"kind":"function","modifiers":[],"name":"verifyCalldata","nameLocation":"5959:14:1","nodeType":"FunctionDefinition","parameters":{"id":272,"nodeType":"ParameterList","parameters":[{"constant":false,"id":257,"mutability":"mutable","name":"proof","nameLocation":"6002:5:1","nodeType":"VariableDeclaration","scope":285,"src":"5983:24:1","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":255,"name":"bytes32","nodeType":"ElementaryTypeName","src":"5983:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":256,"nodeType":"ArrayTypeName","src":"5983:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":259,"mutability":"mutable","name":"root","nameLocation":"6025:4:1","nodeType":"VariableDeclaration","scope":285,"src":"6017:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":258,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6017:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":261,"mutability":"mutable","name":"leaf","nameLocation":"6047:4:1","nodeType":"VariableDeclaration","scope":285,"src":"6039:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":260,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6039:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":271,"mutability":"mutable","name":"hasher","nameLocation":"6111:6:1","nodeType":"VariableDeclaration","scope":285,"src":"6061:56:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"},"typeName":{"id":270,"nodeType":"FunctionTypeName","parameterTypes":{"id":266,"nodeType":"ParameterList","parameters":[{"constant":false,"id":263,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":270,"src":"6070:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":262,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6070:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":265,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":270,"src":"6079:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":264,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6079:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"6069:18:1"},"returnParameterTypes":{"id":269,"nodeType":"ParameterList","parameters":[{"constant":false,"id":268,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":270,"src":"6102:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":267,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6102:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"6101:9:1"},"src":"6061:56:1","stateMutability":"view","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"},"visibility":"internal"},"visibility":"internal"}],"src":"5973:150:1"},"returnParameters":{"id":275,"nodeType":"ParameterList","parameters":[{"constant":false,"id":274,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":285,"src":"6147:4:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":273,"name":"bool","nodeType":"ElementaryTypeName","src":"6147:4:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"6146:6:1"},"scope":1112,"src":"5950:276:1","stateMutability":"view","virtual":false,"visibility":"internal"},{"body":{"id":334,"nodeType":"Block","src":"6816:195:1","statements":[{"assignments":[307],"declarations":[{"constant":false,"id":307,"mutability":"mutable","name":"computedHash","nameLocation":"6834:12:1","nodeType":"VariableDeclaration","scope":334,"src":"6826:20:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":306,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6826:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"id":309,"initialValue":{"id":308,"name":"leaf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":291,"src":"6849:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"6826:27:1"},{"body":{"id":330,"nodeType":"Block","src":"6906:70:1","statements":[{"expression":{"id":328,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":321,"name":"computedHash","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":307,"src":"6920:12:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"id":323,"name":"computedHash","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":307,"src":"6942:12:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"baseExpression":{"id":324,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":289,"src":"6956:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},"id":326,"indexExpression":{"id":325,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":311,"src":"6962:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"6956:8:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"id":322,"name":"hasher","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":301,"src":"6935:6:1","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"}},"id":327,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6935:30:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"6920:45:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":329,"nodeType":"ExpressionStatement","src":"6920:45:1"}]},"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":317,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":314,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":311,"src":"6883:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"expression":{"id":315,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":289,"src":"6887:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},"id":316,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"6893:6:1","memberName":"length","nodeType":"MemberAccess","src":"6887:12:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"6883:16:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":331,"initializationExpression":{"assignments":[311],"declarations":[{"constant":false,"id":311,"mutability":"mutable","name":"i","nameLocation":"6876:1:1","nodeType":"VariableDeclaration","scope":331,"src":"6868:9:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":310,"name":"uint256","nodeType":"ElementaryTypeName","src":"6868:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":313,"initialValue":{"hexValue":"30","id":312,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"6880:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"6868:13:1"},"loopExpression":{"expression":{"id":319,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"6901:3:1","subExpression":{"id":318,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":311,"src":"6901:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":320,"nodeType":"ExpressionStatement","src":"6901:3:1"},"nodeType":"ForStatement","src":"6863:113:1"},{"expression":{"id":332,"name":"computedHash","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":307,"src":"6992:12:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":305,"id":333,"nodeType":"Return","src":"6985:19:1"}]},"documentation":{"id":286,"nodeType":"StructuredDocumentation","src":"6232:389:1","text":" @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n hash matches the root of the tree. When processing the proof, the pairs\n of leaves & pre-images are assumed to be sorted.\n This version handles proofs in calldata with a custom hashing function."},"id":335,"implemented":true,"kind":"function","modifiers":[],"name":"processProofCalldata","nameLocation":"6635:20:1","nodeType":"FunctionDefinition","parameters":{"id":302,"nodeType":"ParameterList","parameters":[{"constant":false,"id":289,"mutability":"mutable","name":"proof","nameLocation":"6684:5:1","nodeType":"VariableDeclaration","scope":335,"src":"6665:24:1","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":287,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6665:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":288,"nodeType":"ArrayTypeName","src":"6665:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":291,"mutability":"mutable","name":"leaf","nameLocation":"6707:4:1","nodeType":"VariableDeclaration","scope":335,"src":"6699:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":290,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6699:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":301,"mutability":"mutable","name":"hasher","nameLocation":"6771:6:1","nodeType":"VariableDeclaration","scope":335,"src":"6721:56:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"},"typeName":{"id":300,"nodeType":"FunctionTypeName","parameterTypes":{"id":296,"nodeType":"ParameterList","parameters":[{"constant":false,"id":293,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":300,"src":"6730:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":292,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6730:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":295,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":300,"src":"6739:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":294,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6739:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"6729:18:1"},"returnParameterTypes":{"id":299,"nodeType":"ParameterList","parameters":[{"constant":false,"id":298,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":300,"src":"6762:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":297,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6762:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"6761:9:1"},"src":"6721:56:1","stateMutability":"view","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"},"visibility":"internal"},"visibility":"internal"}],"src":"6655:128:1"},"returnParameters":{"id":305,"nodeType":"ParameterList","parameters":[{"constant":false,"id":304,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":335,"src":"6807:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":303,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6807:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"6806:9:1"},"scope":1112,"src":"6626:385:1","stateMutability":"view","virtual":false,"visibility":"internal"},{"body":{"id":360,"nodeType":"Block","src":"7797:76:1","statements":[{"expression":{"commonType":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"id":358,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"arguments":[{"id":353,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":339,"src":"7832:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},{"id":354,"name":"proofFlags","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":342,"src":"7839:10:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_memory_ptr","typeString":"bool[] memory"}},{"id":355,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":347,"src":"7851:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"},{"typeIdentifier":"t_array$_t_bool_$dyn_memory_ptr","typeString":"bool[] memory"},{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}],"id":352,"name":"processMultiProof","nodeType":"Identifier","overloadedDeclarations":[519,723],"referencedDeclaration":519,"src":"7814:17:1","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_array$_t_bytes32_$dyn_memory_ptr_$_t_array$_t_bool_$dyn_memory_ptr_$_t_array$_t_bytes32_$dyn_memory_ptr_$returns$_t_bytes32_$","typeString":"function (bytes32[] memory,bool[] memory,bytes32[] memory) pure returns (bytes32)"}},"id":356,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"7814:44:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"id":357,"name":"root","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":344,"src":"7862:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"7814:52:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"functionReturnParameters":351,"id":359,"nodeType":"Return","src":"7807:59:1"}]},"documentation":{"id":336,"nodeType":"StructuredDocumentation","src":"7017:593:1","text":" @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n This version handles multiproofs in memory with the default hashing function.\n CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n The `leaves` must be validated independently. See {processMultiProof}."},"id":361,"implemented":true,"kind":"function","modifiers":[],"name":"multiProofVerify","nameLocation":"7624:16:1","nodeType":"FunctionDefinition","parameters":{"id":348,"nodeType":"ParameterList","parameters":[{"constant":false,"id":339,"mutability":"mutable","name":"proof","nameLocation":"7667:5:1","nodeType":"VariableDeclaration","scope":361,"src":"7650:22:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":337,"name":"bytes32","nodeType":"ElementaryTypeName","src":"7650:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":338,"nodeType":"ArrayTypeName","src":"7650:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":342,"mutability":"mutable","name":"proofFlags","nameLocation":"7696:10:1","nodeType":"VariableDeclaration","scope":361,"src":"7682:24:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_memory_ptr","typeString":"bool[]"},"typeName":{"baseType":{"id":340,"name":"bool","nodeType":"ElementaryTypeName","src":"7682:4:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":341,"nodeType":"ArrayTypeName","src":"7682:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_storage_ptr","typeString":"bool[]"}},"visibility":"internal"},{"constant":false,"id":344,"mutability":"mutable","name":"root","nameLocation":"7724:4:1","nodeType":"VariableDeclaration","scope":361,"src":"7716:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":343,"name":"bytes32","nodeType":"ElementaryTypeName","src":"7716:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":347,"mutability":"mutable","name":"leaves","nameLocation":"7755:6:1","nodeType":"VariableDeclaration","scope":361,"src":"7738:23:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":345,"name":"bytes32","nodeType":"ElementaryTypeName","src":"7738:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":346,"nodeType":"ArrayTypeName","src":"7738:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"}],"src":"7640:127:1"},"returnParameters":{"id":351,"nodeType":"ParameterList","parameters":[{"constant":false,"id":350,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":361,"src":"7791:4:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":349,"name":"bool","nodeType":"ElementaryTypeName","src":"7791:4:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"7790:6:1"},"scope":1112,"src":"7615:258:1","stateMutability":"pure","virtual":false,"visibility":"internal"},{"body":{"id":518,"nodeType":"Block","src":"9159:2104:1","statements":[{"assignments":[377],"declarations":[{"constant":false,"id":377,"mutability":"mutable","name":"leavesLen","nameLocation":"9551:9:1","nodeType":"VariableDeclaration","scope":518,"src":"9543:17:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":376,"name":"uint256","nodeType":"ElementaryTypeName","src":"9543:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":380,"initialValue":{"expression":{"id":378,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":371,"src":"9563:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":379,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"9570:6:1","memberName":"length","nodeType":"MemberAccess","src":"9563:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"VariableDeclarationStatement","src":"9543:33:1"},{"assignments":[382],"declarations":[{"constant":false,"id":382,"mutability":"mutable","name":"proofFlagsLen","nameLocation":"9594:13:1","nodeType":"VariableDeclaration","scope":518,"src":"9586:21:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":381,"name":"uint256","nodeType":"ElementaryTypeName","src":"9586:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":385,"initialValue":{"expression":{"id":383,"name":"proofFlags","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":368,"src":"9610:10:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_memory_ptr","typeString":"bool[] memory"}},"id":384,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"9621:6:1","memberName":"length","nodeType":"MemberAccess","src":"9610:17:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"VariableDeclarationStatement","src":"9586:41:1"},{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":393,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":389,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":386,"name":"leavesLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":377,"src":"9675:9:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"+","rightExpression":{"expression":{"id":387,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":365,"src":"9687:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":388,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"9693:6:1","memberName":"length","nodeType":"MemberAccess","src":"9687:12:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"9675:24:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"!=","rightExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":392,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":390,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":382,"src":"9703:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"+","rightExpression":{"hexValue":"31","id":391,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"9719:1:1","typeDescriptions":{"typeIdentifier":"t_rational_1_by_1","typeString":"int_const 1"},"value":"1"},"src":"9703:17:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"9675:45:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":398,"nodeType":"IfStatement","src":"9671:113:1","trueBody":{"id":397,"nodeType":"Block","src":"9722:62:1","statements":[{"errorCall":{"arguments":[],"expression":{"argumentTypes":[],"id":394,"name":"MerkleProofInvalidMultiproof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":47,"src":"9743:28:1","typeDescriptions":{"typeIdentifier":"t_function_error_pure$__$returns$__$","typeString":"function () pure"}},"id":395,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"9743:30:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":396,"nodeType":"RevertStatement","src":"9736:37:1"}]}},{"assignments":[403],"declarations":[{"constant":false,"id":403,"mutability":"mutable","name":"hashes","nameLocation":"10045:6:1","nodeType":"VariableDeclaration","scope":518,"src":"10028:23:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":401,"name":"bytes32","nodeType":"ElementaryTypeName","src":"10028:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":402,"nodeType":"ArrayTypeName","src":"10028:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"}],"id":409,"initialValue":{"arguments":[{"id":407,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":382,"src":"10068:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":406,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"NewExpression","src":"10054:13:1","typeDescriptions":{"typeIdentifier":"t_function_objectcreation_pure$_t_uint256_$returns$_t_array$_t_bytes32_$dyn_memory_ptr_$","typeString":"function (uint256) pure returns (bytes32[] memory)"},"typeName":{"baseType":{"id":404,"name":"bytes32","nodeType":"ElementaryTypeName","src":"10058:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":405,"nodeType":"ArrayTypeName","src":"10058:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}}},"id":408,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"10054:28:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"nodeType":"VariableDeclarationStatement","src":"10028:54:1"},{"assignments":[411],"declarations":[{"constant":false,"id":411,"mutability":"mutable","name":"leafPos","nameLocation":"10100:7:1","nodeType":"VariableDeclaration","scope":518,"src":"10092:15:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":410,"name":"uint256","nodeType":"ElementaryTypeName","src":"10092:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":413,"initialValue":{"hexValue":"30","id":412,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"10110:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"10092:19:1"},{"assignments":[415],"declarations":[{"constant":false,"id":415,"mutability":"mutable","name":"hashPos","nameLocation":"10129:7:1","nodeType":"VariableDeclaration","scope":518,"src":"10121:15:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":414,"name":"uint256","nodeType":"ElementaryTypeName","src":"10121:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":417,"initialValue":{"hexValue":"30","id":416,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"10139:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"10121:19:1"},{"assignments":[419],"declarations":[{"constant":false,"id":419,"mutability":"mutable","name":"proofPos","nameLocation":"10158:8:1","nodeType":"VariableDeclaration","scope":518,"src":"10150:16:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":418,"name":"uint256","nodeType":"ElementaryTypeName","src":"10150:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":421,"initialValue":{"hexValue":"30","id":420,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"10169:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"10150:20:1"},{"body":{"id":481,"nodeType":"Block","src":"10590:310:1","statements":[{"assignments":[433],"declarations":[{"constant":false,"id":433,"mutability":"mutable","name":"a","nameLocation":"10612:1:1","nodeType":"VariableDeclaration","scope":481,"src":"10604:9:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":432,"name":"bytes32","nodeType":"ElementaryTypeName","src":"10604:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"id":446,"initialValue":{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":436,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":434,"name":"leafPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":411,"src":"10616:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"id":435,"name":"leavesLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":377,"src":"10626:9:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"10616:19:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseExpression":{"baseExpression":{"id":441,"name":"hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":403,"src":"10658:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":444,"indexExpression":{"id":443,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"10665:9:1","subExpression":{"id":442,"name":"hashPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":415,"src":"10665:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"10658:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":445,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"Conditional","src":"10616:59:1","trueExpression":{"baseExpression":{"id":437,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":371,"src":"10638:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":440,"indexExpression":{"id":439,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"10645:9:1","subExpression":{"id":438,"name":"leafPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":411,"src":"10645:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"10638:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"10604:71:1"},{"assignments":[448],"declarations":[{"constant":false,"id":448,"mutability":"mutable","name":"b","nameLocation":"10697:1:1","nodeType":"VariableDeclaration","scope":481,"src":"10689:9:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":447,"name":"bytes32","nodeType":"ElementaryTypeName","src":"10689:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"id":470,"initialValue":{"condition":{"baseExpression":{"id":449,"name":"proofFlags","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":368,"src":"10701:10:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_memory_ptr","typeString":"bool[] memory"}},"id":451,"indexExpression":{"id":450,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":423,"src":"10712:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"10701:13:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseExpression":{"baseExpression":{"id":465,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":365,"src":"10813:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":468,"indexExpression":{"id":467,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"10819:10:1","subExpression":{"id":466,"name":"proofPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":419,"src":"10819:8:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"10813:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":469,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"Conditional","src":"10701:129:1","trueExpression":{"components":[{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":454,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":452,"name":"leafPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":411,"src":"10734:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"id":453,"name":"leavesLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":377,"src":"10744:9:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"10734:19:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseExpression":{"baseExpression":{"id":459,"name":"hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":403,"src":"10776:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":462,"indexExpression":{"id":461,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"10783:9:1","subExpression":{"id":460,"name":"hashPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":415,"src":"10783:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"10776:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":463,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"Conditional","src":"10734:59:1","trueExpression":{"baseExpression":{"id":455,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":371,"src":"10756:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":458,"indexExpression":{"id":457,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"10763:9:1","subExpression":{"id":456,"name":"leafPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":411,"src":"10763:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"10756:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"id":464,"isConstant":false,"isInlineArray":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"TupleExpression","src":"10733:61:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"10689:141:1"},{"expression":{"id":479,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"baseExpression":{"id":471,"name":"hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":403,"src":"10844:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":473,"indexExpression":{"id":472,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":423,"src":"10851:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"10844:9:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"id":476,"name":"a","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":433,"src":"10884:1:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"id":477,"name":"b","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":448,"src":"10887:1:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"expression":{"id":474,"name":"Hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":39,"src":"10856:6:1","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Hashes_$39_$","typeString":"type(library Hashes)"}},"id":475,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"10863:20:1","memberName":"commutativeKeccak256","nodeType":"MemberAccess","referencedDeclaration":26,"src":"10856:27:1","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) pure returns (bytes32)"}},"id":478,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"10856:33:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"10844:45:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":480,"nodeType":"ExpressionStatement","src":"10844:45:1"}]},"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":428,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":426,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":423,"src":"10566:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"id":427,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":382,"src":"10570:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"10566:17:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":482,"initializationExpression":{"assignments":[423],"declarations":[{"constant":false,"id":423,"mutability":"mutable","name":"i","nameLocation":"10559:1:1","nodeType":"VariableDeclaration","scope":482,"src":"10551:9:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":422,"name":"uint256","nodeType":"ElementaryTypeName","src":"10551:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":425,"initialValue":{"hexValue":"30","id":424,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"10563:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"10551:13:1"},"loopExpression":{"expression":{"id":430,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"10585:3:1","subExpression":{"id":429,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":423,"src":"10585:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":431,"nodeType":"ExpressionStatement","src":"10585:3:1"},"nodeType":"ForStatement","src":"10546:354:1"},{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":485,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":483,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":382,"src":"10914:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"hexValue":"30","id":484,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"10930:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"10914:17:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseBody":{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":505,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":503,"name":"leavesLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":377,"src":"11155:9:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"hexValue":"30","id":504,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"11167:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"11155:13:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseBody":{"id":515,"nodeType":"Block","src":"11217:40:1","statements":[{"expression":{"baseExpression":{"id":511,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":365,"src":"11238:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":513,"indexExpression":{"hexValue":"30","id":512,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"11244:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"11238:8:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":375,"id":514,"nodeType":"Return","src":"11231:15:1"}]},"id":516,"nodeType":"IfStatement","src":"11151:106:1","trueBody":{"id":510,"nodeType":"Block","src":"11170:41:1","statements":[{"expression":{"baseExpression":{"id":506,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":371,"src":"11191:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":508,"indexExpression":{"hexValue":"30","id":507,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"11198:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"11191:9:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":375,"id":509,"nodeType":"Return","src":"11184:16:1"}]}},"id":517,"nodeType":"IfStatement","src":"10910:347:1","trueBody":{"id":502,"nodeType":"Block","src":"10933:212:1","statements":[{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":489,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":486,"name":"proofPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":419,"src":"10951:8:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"!=","rightExpression":{"expression":{"id":487,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":365,"src":"10963:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":488,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"10969:6:1","memberName":"length","nodeType":"MemberAccess","src":"10963:12:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"10951:24:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":494,"nodeType":"IfStatement","src":"10947:100:1","trueBody":{"id":493,"nodeType":"Block","src":"10977:70:1","statements":[{"errorCall":{"arguments":[],"expression":{"argumentTypes":[],"id":490,"name":"MerkleProofInvalidMultiproof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":47,"src":"11002:28:1","typeDescriptions":{"typeIdentifier":"t_function_error_pure$__$returns$__$","typeString":"function () pure"}},"id":491,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"11002:30:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":492,"nodeType":"RevertStatement","src":"10995:37:1"}]}},{"id":501,"nodeType":"UncheckedBlock","src":"11060:75:1","statements":[{"expression":{"baseExpression":{"id":495,"name":"hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":403,"src":"11095:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":499,"indexExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":498,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":496,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":382,"src":"11102:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"-","rightExpression":{"hexValue":"31","id":497,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"11118:1:1","typeDescriptions":{"typeIdentifier":"t_rational_1_by_1","typeString":"int_const 1"},"value":"1"},"src":"11102:17:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"11095:25:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":375,"id":500,"nodeType":"Return","src":"11088:32:1"}]}]}}]},"documentation":{"id":362,"nodeType":"StructuredDocumentation","src":"7879:1100:1","text":" @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n respectively.\n This version handles multiproofs in memory with the default hashing function.\n CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n validating the leaves elsewhere."},"id":519,"implemented":true,"kind":"function","modifiers":[],"name":"processMultiProof","nameLocation":"8993:17:1","nodeType":"FunctionDefinition","parameters":{"id":372,"nodeType":"ParameterList","parameters":[{"constant":false,"id":365,"mutability":"mutable","name":"proof","nameLocation":"9037:5:1","nodeType":"VariableDeclaration","scope":519,"src":"9020:22:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":363,"name":"bytes32","nodeType":"ElementaryTypeName","src":"9020:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":364,"nodeType":"ArrayTypeName","src":"9020:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":368,"mutability":"mutable","name":"proofFlags","nameLocation":"9066:10:1","nodeType":"VariableDeclaration","scope":519,"src":"9052:24:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_memory_ptr","typeString":"bool[]"},"typeName":{"baseType":{"id":366,"name":"bool","nodeType":"ElementaryTypeName","src":"9052:4:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":367,"nodeType":"ArrayTypeName","src":"9052:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_storage_ptr","typeString":"bool[]"}},"visibility":"internal"},{"constant":false,"id":371,"mutability":"mutable","name":"leaves","nameLocation":"9103:6:1","nodeType":"VariableDeclaration","scope":519,"src":"9086:23:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":369,"name":"bytes32","nodeType":"ElementaryTypeName","src":"9086:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":370,"nodeType":"ArrayTypeName","src":"9086:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"}],"src":"9010:105:1"},"returnParameters":{"id":375,"nodeType":"ParameterList","parameters":[{"constant":false,"id":374,"mutability":"mutable","name":"merkleRoot","nameLocation":"9147:10:1","nodeType":"VariableDeclaration","scope":519,"src":"9139:18:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":373,"name":"bytes32","nodeType":"ElementaryTypeName","src":"9139:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"9138:20:1"},"scope":1112,"src":"8984:2279:1","stateMutability":"pure","virtual":false,"visibility":"internal"},{"body":{"id":555,"nodeType":"Block","src":"12112:84:1","statements":[{"expression":{"commonType":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"id":553,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"arguments":[{"id":547,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":523,"src":"12147:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},{"id":548,"name":"proofFlags","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":526,"src":"12154:10:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_memory_ptr","typeString":"bool[] memory"}},{"id":549,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":531,"src":"12166:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},{"id":550,"name":"hasher","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":541,"src":"12174:6:1","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"},{"typeIdentifier":"t_array$_t_bool_$dyn_memory_ptr","typeString":"bool[] memory"},{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"},{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"}],"id":546,"name":"processMultiProof","nodeType":"Identifier","overloadedDeclarations":[519,723],"referencedDeclaration":723,"src":"12129:17:1","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_array$_t_bytes32_$dyn_memory_ptr_$_t_array$_t_bool_$dyn_memory_ptr_$_t_array$_t_bytes32_$dyn_memory_ptr_$_t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$_$returns$_t_bytes32_$","typeString":"function (bytes32[] memory,bool[] memory,bytes32[] memory,function (bytes32,bytes32) view returns (bytes32)) view returns (bytes32)"}},"id":551,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"12129:52:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"id":552,"name":"root","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":528,"src":"12185:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"12129:60:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"functionReturnParameters":545,"id":554,"nodeType":"Return","src":"12122:67:1"}]},"documentation":{"id":520,"nodeType":"StructuredDocumentation","src":"11269:590:1","text":" @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n This version handles multiproofs in memory with a custom hashing function.\n CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n The `leaves` must be validated independently. See {processMultiProof}."},"id":556,"implemented":true,"kind":"function","modifiers":[],"name":"multiProofVerify","nameLocation":"11873:16:1","nodeType":"FunctionDefinition","parameters":{"id":542,"nodeType":"ParameterList","parameters":[{"constant":false,"id":523,"mutability":"mutable","name":"proof","nameLocation":"11916:5:1","nodeType":"VariableDeclaration","scope":556,"src":"11899:22:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":521,"name":"bytes32","nodeType":"ElementaryTypeName","src":"11899:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":522,"nodeType":"ArrayTypeName","src":"11899:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":526,"mutability":"mutable","name":"proofFlags","nameLocation":"11945:10:1","nodeType":"VariableDeclaration","scope":556,"src":"11931:24:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_memory_ptr","typeString":"bool[]"},"typeName":{"baseType":{"id":524,"name":"bool","nodeType":"ElementaryTypeName","src":"11931:4:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":525,"nodeType":"ArrayTypeName","src":"11931:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_storage_ptr","typeString":"bool[]"}},"visibility":"internal"},{"constant":false,"id":528,"mutability":"mutable","name":"root","nameLocation":"11973:4:1","nodeType":"VariableDeclaration","scope":556,"src":"11965:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":527,"name":"bytes32","nodeType":"ElementaryTypeName","src":"11965:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":531,"mutability":"mutable","name":"leaves","nameLocation":"12004:6:1","nodeType":"VariableDeclaration","scope":556,"src":"11987:23:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":529,"name":"bytes32","nodeType":"ElementaryTypeName","src":"11987:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":530,"nodeType":"ArrayTypeName","src":"11987:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":541,"mutability":"mutable","name":"hasher","nameLocation":"12070:6:1","nodeType":"VariableDeclaration","scope":556,"src":"12020:56:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"},"typeName":{"id":540,"nodeType":"FunctionTypeName","parameterTypes":{"id":536,"nodeType":"ParameterList","parameters":[{"constant":false,"id":533,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":540,"src":"12029:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":532,"name":"bytes32","nodeType":"ElementaryTypeName","src":"12029:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":535,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":540,"src":"12038:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":534,"name":"bytes32","nodeType":"ElementaryTypeName","src":"12038:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"12028:18:1"},"returnParameterTypes":{"id":539,"nodeType":"ParameterList","parameters":[{"constant":false,"id":538,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":540,"src":"12061:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":537,"name":"bytes32","nodeType":"ElementaryTypeName","src":"12061:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"12060:9:1"},"src":"12020:56:1","stateMutability":"view","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"},"visibility":"internal"},"visibility":"internal"}],"src":"11889:193:1"},"returnParameters":{"id":545,"nodeType":"ParameterList","parameters":[{"constant":false,"id":544,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":556,"src":"12106:4:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":543,"name":"bool","nodeType":"ElementaryTypeName","src":"12106:4:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"12105:6:1"},"scope":1112,"src":"11864:332:1","stateMutability":"view","virtual":false,"visibility":"internal"},{"body":{"id":722,"nodeType":"Block","src":"13545:2083:1","statements":[{"assignments":[582],"declarations":[{"constant":false,"id":582,"mutability":"mutable","name":"leavesLen","nameLocation":"13937:9:1","nodeType":"VariableDeclaration","scope":722,"src":"13929:17:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":581,"name":"uint256","nodeType":"ElementaryTypeName","src":"13929:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":585,"initialValue":{"expression":{"id":583,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":566,"src":"13949:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":584,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"13956:6:1","memberName":"length","nodeType":"MemberAccess","src":"13949:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"VariableDeclarationStatement","src":"13929:33:1"},{"assignments":[587],"declarations":[{"constant":false,"id":587,"mutability":"mutable","name":"proofFlagsLen","nameLocation":"13980:13:1","nodeType":"VariableDeclaration","scope":722,"src":"13972:21:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":586,"name":"uint256","nodeType":"ElementaryTypeName","src":"13972:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":590,"initialValue":{"expression":{"id":588,"name":"proofFlags","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":563,"src":"13996:10:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_memory_ptr","typeString":"bool[] memory"}},"id":589,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"14007:6:1","memberName":"length","nodeType":"MemberAccess","src":"13996:17:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"VariableDeclarationStatement","src":"13972:41:1"},{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":598,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":594,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":591,"name":"leavesLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":582,"src":"14061:9:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"+","rightExpression":{"expression":{"id":592,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":560,"src":"14073:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":593,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"14079:6:1","memberName":"length","nodeType":"MemberAccess","src":"14073:12:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"14061:24:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"!=","rightExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":597,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":595,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":587,"src":"14089:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"+","rightExpression":{"hexValue":"31","id":596,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"14105:1:1","typeDescriptions":{"typeIdentifier":"t_rational_1_by_1","typeString":"int_const 1"},"value":"1"},"src":"14089:17:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"14061:45:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":603,"nodeType":"IfStatement","src":"14057:113:1","trueBody":{"id":602,"nodeType":"Block","src":"14108:62:1","statements":[{"errorCall":{"arguments":[],"expression":{"argumentTypes":[],"id":599,"name":"MerkleProofInvalidMultiproof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":47,"src":"14129:28:1","typeDescriptions":{"typeIdentifier":"t_function_error_pure$__$returns$__$","typeString":"function () pure"}},"id":600,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"14129:30:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":601,"nodeType":"RevertStatement","src":"14122:37:1"}]}},{"assignments":[608],"declarations":[{"constant":false,"id":608,"mutability":"mutable","name":"hashes","nameLocation":"14431:6:1","nodeType":"VariableDeclaration","scope":722,"src":"14414:23:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":606,"name":"bytes32","nodeType":"ElementaryTypeName","src":"14414:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":607,"nodeType":"ArrayTypeName","src":"14414:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"}],"id":614,"initialValue":{"arguments":[{"id":612,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":587,"src":"14454:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":611,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"NewExpression","src":"14440:13:1","typeDescriptions":{"typeIdentifier":"t_function_objectcreation_pure$_t_uint256_$returns$_t_array$_t_bytes32_$dyn_memory_ptr_$","typeString":"function (uint256) pure returns (bytes32[] memory)"},"typeName":{"baseType":{"id":609,"name":"bytes32","nodeType":"ElementaryTypeName","src":"14444:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":610,"nodeType":"ArrayTypeName","src":"14444:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}}},"id":613,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"14440:28:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"nodeType":"VariableDeclarationStatement","src":"14414:54:1"},{"assignments":[616],"declarations":[{"constant":false,"id":616,"mutability":"mutable","name":"leafPos","nameLocation":"14486:7:1","nodeType":"VariableDeclaration","scope":722,"src":"14478:15:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":615,"name":"uint256","nodeType":"ElementaryTypeName","src":"14478:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":618,"initialValue":{"hexValue":"30","id":617,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"14496:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"14478:19:1"},{"assignments":[620],"declarations":[{"constant":false,"id":620,"mutability":"mutable","name":"hashPos","nameLocation":"14515:7:1","nodeType":"VariableDeclaration","scope":722,"src":"14507:15:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":619,"name":"uint256","nodeType":"ElementaryTypeName","src":"14507:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":622,"initialValue":{"hexValue":"30","id":621,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"14525:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"14507:19:1"},{"assignments":[624],"declarations":[{"constant":false,"id":624,"mutability":"mutable","name":"proofPos","nameLocation":"14544:8:1","nodeType":"VariableDeclaration","scope":722,"src":"14536:16:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":623,"name":"uint256","nodeType":"ElementaryTypeName","src":"14536:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":626,"initialValue":{"hexValue":"30","id":625,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"14555:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"14536:20:1"},{"body":{"id":685,"nodeType":"Block","src":"14976:289:1","statements":[{"assignments":[638],"declarations":[{"constant":false,"id":638,"mutability":"mutable","name":"a","nameLocation":"14998:1:1","nodeType":"VariableDeclaration","scope":685,"src":"14990:9:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":637,"name":"bytes32","nodeType":"ElementaryTypeName","src":"14990:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"id":651,"initialValue":{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":641,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":639,"name":"leafPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":616,"src":"15002:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"id":640,"name":"leavesLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":582,"src":"15012:9:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"15002:19:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseExpression":{"baseExpression":{"id":646,"name":"hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":608,"src":"15044:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":649,"indexExpression":{"id":648,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"15051:9:1","subExpression":{"id":647,"name":"hashPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":620,"src":"15051:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"15044:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":650,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"Conditional","src":"15002:59:1","trueExpression":{"baseExpression":{"id":642,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":566,"src":"15024:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":645,"indexExpression":{"id":644,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"15031:9:1","subExpression":{"id":643,"name":"leafPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":616,"src":"15031:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"15024:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"14990:71:1"},{"assignments":[653],"declarations":[{"constant":false,"id":653,"mutability":"mutable","name":"b","nameLocation":"15083:1:1","nodeType":"VariableDeclaration","scope":685,"src":"15075:9:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":652,"name":"bytes32","nodeType":"ElementaryTypeName","src":"15075:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"id":675,"initialValue":{"condition":{"baseExpression":{"id":654,"name":"proofFlags","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":563,"src":"15087:10:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_memory_ptr","typeString":"bool[] memory"}},"id":656,"indexExpression":{"id":655,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":628,"src":"15098:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"15087:13:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseExpression":{"baseExpression":{"id":670,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":560,"src":"15199:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":673,"indexExpression":{"id":672,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"15205:10:1","subExpression":{"id":671,"name":"proofPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":624,"src":"15205:8:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"15199:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":674,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"Conditional","src":"15087:129:1","trueExpression":{"components":[{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":659,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":657,"name":"leafPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":616,"src":"15120:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"id":658,"name":"leavesLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":582,"src":"15130:9:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"15120:19:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseExpression":{"baseExpression":{"id":664,"name":"hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":608,"src":"15162:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":667,"indexExpression":{"id":666,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"15169:9:1","subExpression":{"id":665,"name":"hashPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":620,"src":"15169:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"15162:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":668,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"Conditional","src":"15120:59:1","trueExpression":{"baseExpression":{"id":660,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":566,"src":"15142:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":663,"indexExpression":{"id":662,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"15149:9:1","subExpression":{"id":661,"name":"leafPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":616,"src":"15149:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"15142:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"id":669,"isConstant":false,"isInlineArray":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"TupleExpression","src":"15119:61:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"15075:141:1"},{"expression":{"id":683,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"baseExpression":{"id":676,"name":"hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":608,"src":"15230:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":678,"indexExpression":{"id":677,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":628,"src":"15237:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"15230:9:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"id":680,"name":"a","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":638,"src":"15249:1:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"id":681,"name":"b","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":653,"src":"15252:1:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"id":679,"name":"hasher","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":576,"src":"15242:6:1","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"}},"id":682,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"15242:12:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"15230:24:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":684,"nodeType":"ExpressionStatement","src":"15230:24:1"}]},"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":633,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":631,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":628,"src":"14952:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"id":632,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":587,"src":"14956:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"14952:17:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":686,"initializationExpression":{"assignments":[628],"declarations":[{"constant":false,"id":628,"mutability":"mutable","name":"i","nameLocation":"14945:1:1","nodeType":"VariableDeclaration","scope":686,"src":"14937:9:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":627,"name":"uint256","nodeType":"ElementaryTypeName","src":"14937:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":630,"initialValue":{"hexValue":"30","id":629,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"14949:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"14937:13:1"},"loopExpression":{"expression":{"id":635,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"14971:3:1","subExpression":{"id":634,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":628,"src":"14971:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":636,"nodeType":"ExpressionStatement","src":"14971:3:1"},"nodeType":"ForStatement","src":"14932:333:1"},{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":689,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":687,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":587,"src":"15279:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"hexValue":"30","id":688,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"15295:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"15279:17:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseBody":{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":709,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":707,"name":"leavesLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":582,"src":"15520:9:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"hexValue":"30","id":708,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"15532:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"15520:13:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseBody":{"id":719,"nodeType":"Block","src":"15582:40:1","statements":[{"expression":{"baseExpression":{"id":715,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":560,"src":"15603:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":717,"indexExpression":{"hexValue":"30","id":716,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"15609:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"15603:8:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":580,"id":718,"nodeType":"Return","src":"15596:15:1"}]},"id":720,"nodeType":"IfStatement","src":"15516:106:1","trueBody":{"id":714,"nodeType":"Block","src":"15535:41:1","statements":[{"expression":{"baseExpression":{"id":710,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":566,"src":"15556:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":712,"indexExpression":{"hexValue":"30","id":711,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"15563:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"15556:9:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":580,"id":713,"nodeType":"Return","src":"15549:16:1"}]}},"id":721,"nodeType":"IfStatement","src":"15275:347:1","trueBody":{"id":706,"nodeType":"Block","src":"15298:212:1","statements":[{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":693,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":690,"name":"proofPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":624,"src":"15316:8:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"!=","rightExpression":{"expression":{"id":691,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":560,"src":"15328:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":692,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"15334:6:1","memberName":"length","nodeType":"MemberAccess","src":"15328:12:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"15316:24:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":698,"nodeType":"IfStatement","src":"15312:100:1","trueBody":{"id":697,"nodeType":"Block","src":"15342:70:1","statements":[{"errorCall":{"arguments":[],"expression":{"argumentTypes":[],"id":694,"name":"MerkleProofInvalidMultiproof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":47,"src":"15367:28:1","typeDescriptions":{"typeIdentifier":"t_function_error_pure$__$returns$__$","typeString":"function () pure"}},"id":695,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"15367:30:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":696,"nodeType":"RevertStatement","src":"15360:37:1"}]}},{"id":705,"nodeType":"UncheckedBlock","src":"15425:75:1","statements":[{"expression":{"baseExpression":{"id":699,"name":"hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":608,"src":"15460:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":703,"indexExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":702,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":700,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":587,"src":"15467:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"-","rightExpression":{"hexValue":"31","id":701,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"15483:1:1","typeDescriptions":{"typeIdentifier":"t_rational_1_by_1","typeString":"int_const 1"},"value":"1"},"src":"15467:17:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"15460:25:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":580,"id":704,"nodeType":"Return","src":"15453:32:1"}]}]}}]},"documentation":{"id":557,"nodeType":"StructuredDocumentation","src":"12202:1097:1","text":" @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n respectively.\n This version handles multiproofs in memory with a custom hashing function.\n CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n validating the leaves elsewhere."},"id":723,"implemented":true,"kind":"function","modifiers":[],"name":"processMultiProof","nameLocation":"13313:17:1","nodeType":"FunctionDefinition","parameters":{"id":577,"nodeType":"ParameterList","parameters":[{"constant":false,"id":560,"mutability":"mutable","name":"proof","nameLocation":"13357:5:1","nodeType":"VariableDeclaration","scope":723,"src":"13340:22:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":558,"name":"bytes32","nodeType":"ElementaryTypeName","src":"13340:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":559,"nodeType":"ArrayTypeName","src":"13340:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":563,"mutability":"mutable","name":"proofFlags","nameLocation":"13386:10:1","nodeType":"VariableDeclaration","scope":723,"src":"13372:24:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_memory_ptr","typeString":"bool[]"},"typeName":{"baseType":{"id":561,"name":"bool","nodeType":"ElementaryTypeName","src":"13372:4:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":562,"nodeType":"ArrayTypeName","src":"13372:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_storage_ptr","typeString":"bool[]"}},"visibility":"internal"},{"constant":false,"id":566,"mutability":"mutable","name":"leaves","nameLocation":"13423:6:1","nodeType":"VariableDeclaration","scope":723,"src":"13406:23:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":564,"name":"bytes32","nodeType":"ElementaryTypeName","src":"13406:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":565,"nodeType":"ArrayTypeName","src":"13406:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":576,"mutability":"mutable","name":"hasher","nameLocation":"13489:6:1","nodeType":"VariableDeclaration","scope":723,"src":"13439:56:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"},"typeName":{"id":575,"nodeType":"FunctionTypeName","parameterTypes":{"id":571,"nodeType":"ParameterList","parameters":[{"constant":false,"id":568,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":575,"src":"13448:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":567,"name":"bytes32","nodeType":"ElementaryTypeName","src":"13448:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":570,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":575,"src":"13457:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":569,"name":"bytes32","nodeType":"ElementaryTypeName","src":"13457:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"13447:18:1"},"returnParameterTypes":{"id":574,"nodeType":"ParameterList","parameters":[{"constant":false,"id":573,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":575,"src":"13480:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":572,"name":"bytes32","nodeType":"ElementaryTypeName","src":"13480:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"13479:9:1"},"src":"13439:56:1","stateMutability":"view","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"},"visibility":"internal"},"visibility":"internal"}],"src":"13330:171:1"},"returnParameters":{"id":580,"nodeType":"ParameterList","parameters":[{"constant":false,"id":579,"mutability":"mutable","name":"merkleRoot","nameLocation":"13533:10:1","nodeType":"VariableDeclaration","scope":723,"src":"13525:18:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":578,"name":"bytes32","nodeType":"ElementaryTypeName","src":"13525:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"13524:20:1"},"scope":1112,"src":"13304:2324:1","stateMutability":"view","virtual":false,"visibility":"internal"},{"body":{"id":748,"nodeType":"Block","src":"16436:84:1","statements":[{"expression":{"commonType":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"id":746,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"arguments":[{"id":741,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":727,"src":"16479:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},{"id":742,"name":"proofFlags","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":730,"src":"16486:10:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_calldata_ptr","typeString":"bool[] calldata"}},{"id":743,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":735,"src":"16498:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"},{"typeIdentifier":"t_array$_t_bool_$dyn_calldata_ptr","typeString":"bool[] calldata"},{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}],"id":740,"name":"processMultiProofCalldata","nodeType":"Identifier","overloadedDeclarations":[907,1111],"referencedDeclaration":907,"src":"16453:25:1","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_array$_t_bytes32_$dyn_calldata_ptr_$_t_array$_t_bool_$dyn_calldata_ptr_$_t_array$_t_bytes32_$dyn_memory_ptr_$returns$_t_bytes32_$","typeString":"function (bytes32[] calldata,bool[] calldata,bytes32[] memory) pure returns (bytes32)"}},"id":744,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"16453:52:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"id":745,"name":"root","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":732,"src":"16509:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"16453:60:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"functionReturnParameters":739,"id":747,"nodeType":"Return","src":"16446:67:1"}]},"documentation":{"id":724,"nodeType":"StructuredDocumentation","src":"15634:603:1","text":" @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n This version handles multiproofs in calldata with the default hashing function.\n CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n The `leaves` must be validated independently. See {processMultiProofCalldata}."},"id":749,"implemented":true,"kind":"function","modifiers":[],"name":"multiProofVerifyCalldata","nameLocation":"16251:24:1","nodeType":"FunctionDefinition","parameters":{"id":736,"nodeType":"ParameterList","parameters":[{"constant":false,"id":727,"mutability":"mutable","name":"proof","nameLocation":"16304:5:1","nodeType":"VariableDeclaration","scope":749,"src":"16285:24:1","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":725,"name":"bytes32","nodeType":"ElementaryTypeName","src":"16285:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":726,"nodeType":"ArrayTypeName","src":"16285:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":730,"mutability":"mutable","name":"proofFlags","nameLocation":"16335:10:1","nodeType":"VariableDeclaration","scope":749,"src":"16319:26:1","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_calldata_ptr","typeString":"bool[]"},"typeName":{"baseType":{"id":728,"name":"bool","nodeType":"ElementaryTypeName","src":"16319:4:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":729,"nodeType":"ArrayTypeName","src":"16319:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_storage_ptr","typeString":"bool[]"}},"visibility":"internal"},{"constant":false,"id":732,"mutability":"mutable","name":"root","nameLocation":"16363:4:1","nodeType":"VariableDeclaration","scope":749,"src":"16355:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":731,"name":"bytes32","nodeType":"ElementaryTypeName","src":"16355:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":735,"mutability":"mutable","name":"leaves","nameLocation":"16394:6:1","nodeType":"VariableDeclaration","scope":749,"src":"16377:23:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":733,"name":"bytes32","nodeType":"ElementaryTypeName","src":"16377:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":734,"nodeType":"ArrayTypeName","src":"16377:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"}],"src":"16275:131:1"},"returnParameters":{"id":739,"nodeType":"ParameterList","parameters":[{"constant":false,"id":738,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":749,"src":"16430:4:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":737,"name":"bool","nodeType":"ElementaryTypeName","src":"16430:4:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"16429:6:1"},"scope":1112,"src":"16242:278:1","stateMutability":"pure","virtual":false,"visibility":"internal"},{"body":{"id":906,"nodeType":"Block","src":"17820:2104:1","statements":[{"assignments":[765],"declarations":[{"constant":false,"id":765,"mutability":"mutable","name":"leavesLen","nameLocation":"18212:9:1","nodeType":"VariableDeclaration","scope":906,"src":"18204:17:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":764,"name":"uint256","nodeType":"ElementaryTypeName","src":"18204:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":768,"initialValue":{"expression":{"id":766,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":759,"src":"18224:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":767,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"18231:6:1","memberName":"length","nodeType":"MemberAccess","src":"18224:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"VariableDeclarationStatement","src":"18204:33:1"},{"assignments":[770],"declarations":[{"constant":false,"id":770,"mutability":"mutable","name":"proofFlagsLen","nameLocation":"18255:13:1","nodeType":"VariableDeclaration","scope":906,"src":"18247:21:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":769,"name":"uint256","nodeType":"ElementaryTypeName","src":"18247:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":773,"initialValue":{"expression":{"id":771,"name":"proofFlags","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":756,"src":"18271:10:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_calldata_ptr","typeString":"bool[] calldata"}},"id":772,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"18282:6:1","memberName":"length","nodeType":"MemberAccess","src":"18271:17:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"VariableDeclarationStatement","src":"18247:41:1"},{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":781,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":777,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":774,"name":"leavesLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":765,"src":"18336:9:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"+","rightExpression":{"expression":{"id":775,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":753,"src":"18348:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},"id":776,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"18354:6:1","memberName":"length","nodeType":"MemberAccess","src":"18348:12:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"18336:24:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"!=","rightExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":780,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":778,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":770,"src":"18364:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"+","rightExpression":{"hexValue":"31","id":779,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"18380:1:1","typeDescriptions":{"typeIdentifier":"t_rational_1_by_1","typeString":"int_const 1"},"value":"1"},"src":"18364:17:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"18336:45:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":786,"nodeType":"IfStatement","src":"18332:113:1","trueBody":{"id":785,"nodeType":"Block","src":"18383:62:1","statements":[{"errorCall":{"arguments":[],"expression":{"argumentTypes":[],"id":782,"name":"MerkleProofInvalidMultiproof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":47,"src":"18404:28:1","typeDescriptions":{"typeIdentifier":"t_function_error_pure$__$returns$__$","typeString":"function () pure"}},"id":783,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"18404:30:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":784,"nodeType":"RevertStatement","src":"18397:37:1"}]}},{"assignments":[791],"declarations":[{"constant":false,"id":791,"mutability":"mutable","name":"hashes","nameLocation":"18706:6:1","nodeType":"VariableDeclaration","scope":906,"src":"18689:23:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":789,"name":"bytes32","nodeType":"ElementaryTypeName","src":"18689:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":790,"nodeType":"ArrayTypeName","src":"18689:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"}],"id":797,"initialValue":{"arguments":[{"id":795,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":770,"src":"18729:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":794,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"NewExpression","src":"18715:13:1","typeDescriptions":{"typeIdentifier":"t_function_objectcreation_pure$_t_uint256_$returns$_t_array$_t_bytes32_$dyn_memory_ptr_$","typeString":"function (uint256) pure returns (bytes32[] memory)"},"typeName":{"baseType":{"id":792,"name":"bytes32","nodeType":"ElementaryTypeName","src":"18719:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":793,"nodeType":"ArrayTypeName","src":"18719:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}}},"id":796,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"18715:28:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"nodeType":"VariableDeclarationStatement","src":"18689:54:1"},{"assignments":[799],"declarations":[{"constant":false,"id":799,"mutability":"mutable","name":"leafPos","nameLocation":"18761:7:1","nodeType":"VariableDeclaration","scope":906,"src":"18753:15:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":798,"name":"uint256","nodeType":"ElementaryTypeName","src":"18753:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":801,"initialValue":{"hexValue":"30","id":800,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"18771:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"18753:19:1"},{"assignments":[803],"declarations":[{"constant":false,"id":803,"mutability":"mutable","name":"hashPos","nameLocation":"18790:7:1","nodeType":"VariableDeclaration","scope":906,"src":"18782:15:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":802,"name":"uint256","nodeType":"ElementaryTypeName","src":"18782:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":805,"initialValue":{"hexValue":"30","id":804,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"18800:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"18782:19:1"},{"assignments":[807],"declarations":[{"constant":false,"id":807,"mutability":"mutable","name":"proofPos","nameLocation":"18819:8:1","nodeType":"VariableDeclaration","scope":906,"src":"18811:16:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":806,"name":"uint256","nodeType":"ElementaryTypeName","src":"18811:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":809,"initialValue":{"hexValue":"30","id":808,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"18830:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"18811:20:1"},{"body":{"id":869,"nodeType":"Block","src":"19251:310:1","statements":[{"assignments":[821],"declarations":[{"constant":false,"id":821,"mutability":"mutable","name":"a","nameLocation":"19273:1:1","nodeType":"VariableDeclaration","scope":869,"src":"19265:9:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":820,"name":"bytes32","nodeType":"ElementaryTypeName","src":"19265:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"id":834,"initialValue":{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":824,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":822,"name":"leafPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":799,"src":"19277:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"id":823,"name":"leavesLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":765,"src":"19287:9:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"19277:19:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseExpression":{"baseExpression":{"id":829,"name":"hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":791,"src":"19319:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":832,"indexExpression":{"id":831,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"19326:9:1","subExpression":{"id":830,"name":"hashPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":803,"src":"19326:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"19319:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":833,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"Conditional","src":"19277:59:1","trueExpression":{"baseExpression":{"id":825,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":759,"src":"19299:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":828,"indexExpression":{"id":827,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"19306:9:1","subExpression":{"id":826,"name":"leafPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":799,"src":"19306:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"19299:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"19265:71:1"},{"assignments":[836],"declarations":[{"constant":false,"id":836,"mutability":"mutable","name":"b","nameLocation":"19358:1:1","nodeType":"VariableDeclaration","scope":869,"src":"19350:9:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":835,"name":"bytes32","nodeType":"ElementaryTypeName","src":"19350:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"id":858,"initialValue":{"condition":{"baseExpression":{"id":837,"name":"proofFlags","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":756,"src":"19362:10:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_calldata_ptr","typeString":"bool[] calldata"}},"id":839,"indexExpression":{"id":838,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":811,"src":"19373:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"19362:13:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseExpression":{"baseExpression":{"id":853,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":753,"src":"19474:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},"id":856,"indexExpression":{"id":855,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"19480:10:1","subExpression":{"id":854,"name":"proofPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":807,"src":"19480:8:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"19474:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":857,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"Conditional","src":"19362:129:1","trueExpression":{"components":[{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":842,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":840,"name":"leafPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":799,"src":"19395:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"id":841,"name":"leavesLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":765,"src":"19405:9:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"19395:19:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseExpression":{"baseExpression":{"id":847,"name":"hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":791,"src":"19437:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":850,"indexExpression":{"id":849,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"19444:9:1","subExpression":{"id":848,"name":"hashPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":803,"src":"19444:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"19437:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":851,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"Conditional","src":"19395:59:1","trueExpression":{"baseExpression":{"id":843,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":759,"src":"19417:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":846,"indexExpression":{"id":845,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"19424:9:1","subExpression":{"id":844,"name":"leafPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":799,"src":"19424:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"19417:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"id":852,"isConstant":false,"isInlineArray":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"TupleExpression","src":"19394:61:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"19350:141:1"},{"expression":{"id":867,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"baseExpression":{"id":859,"name":"hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":791,"src":"19505:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":861,"indexExpression":{"id":860,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":811,"src":"19512:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"19505:9:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"id":864,"name":"a","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":821,"src":"19545:1:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"id":865,"name":"b","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":836,"src":"19548:1:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"expression":{"id":862,"name":"Hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":39,"src":"19517:6:1","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Hashes_$39_$","typeString":"type(library Hashes)"}},"id":863,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"19524:20:1","memberName":"commutativeKeccak256","nodeType":"MemberAccess","referencedDeclaration":26,"src":"19517:27:1","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) pure returns (bytes32)"}},"id":866,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"19517:33:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"19505:45:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":868,"nodeType":"ExpressionStatement","src":"19505:45:1"}]},"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":816,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":814,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":811,"src":"19227:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"id":815,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":770,"src":"19231:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"19227:17:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":870,"initializationExpression":{"assignments":[811],"declarations":[{"constant":false,"id":811,"mutability":"mutable","name":"i","nameLocation":"19220:1:1","nodeType":"VariableDeclaration","scope":870,"src":"19212:9:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":810,"name":"uint256","nodeType":"ElementaryTypeName","src":"19212:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":813,"initialValue":{"hexValue":"30","id":812,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"19224:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"19212:13:1"},"loopExpression":{"expression":{"id":818,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"19246:3:1","subExpression":{"id":817,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":811,"src":"19246:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":819,"nodeType":"ExpressionStatement","src":"19246:3:1"},"nodeType":"ForStatement","src":"19207:354:1"},{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":873,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":871,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":770,"src":"19575:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"hexValue":"30","id":872,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"19591:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"19575:17:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseBody":{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":893,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":891,"name":"leavesLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":765,"src":"19816:9:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"hexValue":"30","id":892,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"19828:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"19816:13:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseBody":{"id":903,"nodeType":"Block","src":"19878:40:1","statements":[{"expression":{"baseExpression":{"id":899,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":753,"src":"19899:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},"id":901,"indexExpression":{"hexValue":"30","id":900,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"19905:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"19899:8:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":763,"id":902,"nodeType":"Return","src":"19892:15:1"}]},"id":904,"nodeType":"IfStatement","src":"19812:106:1","trueBody":{"id":898,"nodeType":"Block","src":"19831:41:1","statements":[{"expression":{"baseExpression":{"id":894,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":759,"src":"19852:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":896,"indexExpression":{"hexValue":"30","id":895,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"19859:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"19852:9:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":763,"id":897,"nodeType":"Return","src":"19845:16:1"}]}},"id":905,"nodeType":"IfStatement","src":"19571:347:1","trueBody":{"id":890,"nodeType":"Block","src":"19594:212:1","statements":[{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":877,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":874,"name":"proofPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":807,"src":"19612:8:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"!=","rightExpression":{"expression":{"id":875,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":753,"src":"19624:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},"id":876,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"19630:6:1","memberName":"length","nodeType":"MemberAccess","src":"19624:12:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"19612:24:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":882,"nodeType":"IfStatement","src":"19608:100:1","trueBody":{"id":881,"nodeType":"Block","src":"19638:70:1","statements":[{"errorCall":{"arguments":[],"expression":{"argumentTypes":[],"id":878,"name":"MerkleProofInvalidMultiproof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":47,"src":"19663:28:1","typeDescriptions":{"typeIdentifier":"t_function_error_pure$__$returns$__$","typeString":"function () pure"}},"id":879,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"19663:30:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":880,"nodeType":"RevertStatement","src":"19656:37:1"}]}},{"id":889,"nodeType":"UncheckedBlock","src":"19721:75:1","statements":[{"expression":{"baseExpression":{"id":883,"name":"hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":791,"src":"19756:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":887,"indexExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":886,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":884,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":770,"src":"19763:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"-","rightExpression":{"hexValue":"31","id":885,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"19779:1:1","typeDescriptions":{"typeIdentifier":"t_rational_1_by_1","typeString":"int_const 1"},"value":"1"},"src":"19763:17:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"19756:25:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":763,"id":888,"nodeType":"Return","src":"19749:32:1"}]}]}}]},"documentation":{"id":750,"nodeType":"StructuredDocumentation","src":"16526:1102:1","text":" @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n respectively.\n This version handles multiproofs in calldata with the default hashing function.\n CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n validating the leaves elsewhere."},"id":907,"implemented":true,"kind":"function","modifiers":[],"name":"processMultiProofCalldata","nameLocation":"17642:25:1","nodeType":"FunctionDefinition","parameters":{"id":760,"nodeType":"ParameterList","parameters":[{"constant":false,"id":753,"mutability":"mutable","name":"proof","nameLocation":"17696:5:1","nodeType":"VariableDeclaration","scope":907,"src":"17677:24:1","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":751,"name":"bytes32","nodeType":"ElementaryTypeName","src":"17677:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":752,"nodeType":"ArrayTypeName","src":"17677:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":756,"mutability":"mutable","name":"proofFlags","nameLocation":"17727:10:1","nodeType":"VariableDeclaration","scope":907,"src":"17711:26:1","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_calldata_ptr","typeString":"bool[]"},"typeName":{"baseType":{"id":754,"name":"bool","nodeType":"ElementaryTypeName","src":"17711:4:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":755,"nodeType":"ArrayTypeName","src":"17711:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_storage_ptr","typeString":"bool[]"}},"visibility":"internal"},{"constant":false,"id":759,"mutability":"mutable","name":"leaves","nameLocation":"17764:6:1","nodeType":"VariableDeclaration","scope":907,"src":"17747:23:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":757,"name":"bytes32","nodeType":"ElementaryTypeName","src":"17747:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":758,"nodeType":"ArrayTypeName","src":"17747:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"}],"src":"17667:109:1"},"returnParameters":{"id":763,"nodeType":"ParameterList","parameters":[{"constant":false,"id":762,"mutability":"mutable","name":"merkleRoot","nameLocation":"17808:10:1","nodeType":"VariableDeclaration","scope":907,"src":"17800:18:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":761,"name":"bytes32","nodeType":"ElementaryTypeName","src":"17800:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"17799:20:1"},"scope":1112,"src":"17633:2291:1","stateMutability":"pure","virtual":false,"visibility":"internal"},{"body":{"id":943,"nodeType":"Block","src":"20795:92:1","statements":[{"expression":{"commonType":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"id":941,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"arguments":[{"id":935,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":911,"src":"20838:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},{"id":936,"name":"proofFlags","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":914,"src":"20845:10:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_calldata_ptr","typeString":"bool[] calldata"}},{"id":937,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":919,"src":"20857:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},{"id":938,"name":"hasher","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":929,"src":"20865:6:1","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"},{"typeIdentifier":"t_array$_t_bool_$dyn_calldata_ptr","typeString":"bool[] calldata"},{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"},{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"}],"id":934,"name":"processMultiProofCalldata","nodeType":"Identifier","overloadedDeclarations":[907,1111],"referencedDeclaration":1111,"src":"20812:25:1","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_array$_t_bytes32_$dyn_calldata_ptr_$_t_array$_t_bool_$dyn_calldata_ptr_$_t_array$_t_bytes32_$dyn_memory_ptr_$_t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$_$returns$_t_bytes32_$","typeString":"function (bytes32[] calldata,bool[] calldata,bytes32[] memory,function (bytes32,bytes32) view returns (bytes32)) view returns (bytes32)"}},"id":939,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"20812:60:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"id":940,"name":"root","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":916,"src":"20876:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"20812:68:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"functionReturnParameters":933,"id":942,"nodeType":"Return","src":"20805:75:1"}]},"documentation":{"id":908,"nodeType":"StructuredDocumentation","src":"19930:600:1","text":" @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n This version handles multiproofs in calldata with a custom hashing function.\n CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n The `leaves` must be validated independently. See {processMultiProofCalldata}."},"id":944,"implemented":true,"kind":"function","modifiers":[],"name":"multiProofVerifyCalldata","nameLocation":"20544:24:1","nodeType":"FunctionDefinition","parameters":{"id":930,"nodeType":"ParameterList","parameters":[{"constant":false,"id":911,"mutability":"mutable","name":"proof","nameLocation":"20597:5:1","nodeType":"VariableDeclaration","scope":944,"src":"20578:24:1","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":909,"name":"bytes32","nodeType":"ElementaryTypeName","src":"20578:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":910,"nodeType":"ArrayTypeName","src":"20578:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":914,"mutability":"mutable","name":"proofFlags","nameLocation":"20628:10:1","nodeType":"VariableDeclaration","scope":944,"src":"20612:26:1","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_calldata_ptr","typeString":"bool[]"},"typeName":{"baseType":{"id":912,"name":"bool","nodeType":"ElementaryTypeName","src":"20612:4:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":913,"nodeType":"ArrayTypeName","src":"20612:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_storage_ptr","typeString":"bool[]"}},"visibility":"internal"},{"constant":false,"id":916,"mutability":"mutable","name":"root","nameLocation":"20656:4:1","nodeType":"VariableDeclaration","scope":944,"src":"20648:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":915,"name":"bytes32","nodeType":"ElementaryTypeName","src":"20648:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":919,"mutability":"mutable","name":"leaves","nameLocation":"20687:6:1","nodeType":"VariableDeclaration","scope":944,"src":"20670:23:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":917,"name":"bytes32","nodeType":"ElementaryTypeName","src":"20670:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":918,"nodeType":"ArrayTypeName","src":"20670:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":929,"mutability":"mutable","name":"hasher","nameLocation":"20753:6:1","nodeType":"VariableDeclaration","scope":944,"src":"20703:56:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"},"typeName":{"id":928,"nodeType":"FunctionTypeName","parameterTypes":{"id":924,"nodeType":"ParameterList","parameters":[{"constant":false,"id":921,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":928,"src":"20712:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":920,"name":"bytes32","nodeType":"ElementaryTypeName","src":"20712:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":923,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":928,"src":"20721:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":922,"name":"bytes32","nodeType":"ElementaryTypeName","src":"20721:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"20711:18:1"},"returnParameterTypes":{"id":927,"nodeType":"ParameterList","parameters":[{"constant":false,"id":926,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":928,"src":"20744:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":925,"name":"bytes32","nodeType":"ElementaryTypeName","src":"20744:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"20743:9:1"},"src":"20703:56:1","stateMutability":"view","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"},"visibility":"internal"},"visibility":"internal"}],"src":"20568:197:1"},"returnParameters":{"id":933,"nodeType":"ParameterList","parameters":[{"constant":false,"id":932,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":944,"src":"20789:4:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":931,"name":"bool","nodeType":"ElementaryTypeName","src":"20789:4:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"20788:6:1"},"scope":1112,"src":"20535:352:1","stateMutability":"view","virtual":false,"visibility":"internal"},{"body":{"id":1110,"nodeType":"Block","src":"22250:2083:1","statements":[{"assignments":[970],"declarations":[{"constant":false,"id":970,"mutability":"mutable","name":"leavesLen","nameLocation":"22642:9:1","nodeType":"VariableDeclaration","scope":1110,"src":"22634:17:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":969,"name":"uint256","nodeType":"ElementaryTypeName","src":"22634:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":973,"initialValue":{"expression":{"id":971,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":954,"src":"22654:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":972,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"22661:6:1","memberName":"length","nodeType":"MemberAccess","src":"22654:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"VariableDeclarationStatement","src":"22634:33:1"},{"assignments":[975],"declarations":[{"constant":false,"id":975,"mutability":"mutable","name":"proofFlagsLen","nameLocation":"22685:13:1","nodeType":"VariableDeclaration","scope":1110,"src":"22677:21:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":974,"name":"uint256","nodeType":"ElementaryTypeName","src":"22677:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":978,"initialValue":{"expression":{"id":976,"name":"proofFlags","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":951,"src":"22701:10:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_calldata_ptr","typeString":"bool[] calldata"}},"id":977,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"22712:6:1","memberName":"length","nodeType":"MemberAccess","src":"22701:17:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"VariableDeclarationStatement","src":"22677:41:1"},{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":986,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":982,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":979,"name":"leavesLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":970,"src":"22766:9:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"+","rightExpression":{"expression":{"id":980,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":948,"src":"22778:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},"id":981,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"22784:6:1","memberName":"length","nodeType":"MemberAccess","src":"22778:12:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"22766:24:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"!=","rightExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":985,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":983,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":975,"src":"22794:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"+","rightExpression":{"hexValue":"31","id":984,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"22810:1:1","typeDescriptions":{"typeIdentifier":"t_rational_1_by_1","typeString":"int_const 1"},"value":"1"},"src":"22794:17:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"22766:45:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":991,"nodeType":"IfStatement","src":"22762:113:1","trueBody":{"id":990,"nodeType":"Block","src":"22813:62:1","statements":[{"errorCall":{"arguments":[],"expression":{"argumentTypes":[],"id":987,"name":"MerkleProofInvalidMultiproof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":47,"src":"22834:28:1","typeDescriptions":{"typeIdentifier":"t_function_error_pure$__$returns$__$","typeString":"function () pure"}},"id":988,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"22834:30:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":989,"nodeType":"RevertStatement","src":"22827:37:1"}]}},{"assignments":[996],"declarations":[{"constant":false,"id":996,"mutability":"mutable","name":"hashes","nameLocation":"23136:6:1","nodeType":"VariableDeclaration","scope":1110,"src":"23119:23:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":994,"name":"bytes32","nodeType":"ElementaryTypeName","src":"23119:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":995,"nodeType":"ArrayTypeName","src":"23119:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"}],"id":1002,"initialValue":{"arguments":[{"id":1000,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":975,"src":"23159:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":999,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"NewExpression","src":"23145:13:1","typeDescriptions":{"typeIdentifier":"t_function_objectcreation_pure$_t_uint256_$returns$_t_array$_t_bytes32_$dyn_memory_ptr_$","typeString":"function (uint256) pure returns (bytes32[] memory)"},"typeName":{"baseType":{"id":997,"name":"bytes32","nodeType":"ElementaryTypeName","src":"23149:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":998,"nodeType":"ArrayTypeName","src":"23149:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}}},"id":1001,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"23145:28:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"nodeType":"VariableDeclarationStatement","src":"23119:54:1"},{"assignments":[1004],"declarations":[{"constant":false,"id":1004,"mutability":"mutable","name":"leafPos","nameLocation":"23191:7:1","nodeType":"VariableDeclaration","scope":1110,"src":"23183:15:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":1003,"name":"uint256","nodeType":"ElementaryTypeName","src":"23183:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":1006,"initialValue":{"hexValue":"30","id":1005,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"23201:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"23183:19:1"},{"assignments":[1008],"declarations":[{"constant":false,"id":1008,"mutability":"mutable","name":"hashPos","nameLocation":"23220:7:1","nodeType":"VariableDeclaration","scope":1110,"src":"23212:15:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":1007,"name":"uint256","nodeType":"ElementaryTypeName","src":"23212:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":1010,"initialValue":{"hexValue":"30","id":1009,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"23230:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"23212:19:1"},{"assignments":[1012],"declarations":[{"constant":false,"id":1012,"mutability":"mutable","name":"proofPos","nameLocation":"23249:8:1","nodeType":"VariableDeclaration","scope":1110,"src":"23241:16:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":1011,"name":"uint256","nodeType":"ElementaryTypeName","src":"23241:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":1014,"initialValue":{"hexValue":"30","id":1013,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"23260:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"23241:20:1"},{"body":{"id":1073,"nodeType":"Block","src":"23681:289:1","statements":[{"assignments":[1026],"declarations":[{"constant":false,"id":1026,"mutability":"mutable","name":"a","nameLocation":"23703:1:1","nodeType":"VariableDeclaration","scope":1073,"src":"23695:9:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":1025,"name":"bytes32","nodeType":"ElementaryTypeName","src":"23695:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"id":1039,"initialValue":{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":1029,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":1027,"name":"leafPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1004,"src":"23707:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"id":1028,"name":"leavesLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":970,"src":"23717:9:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"23707:19:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseExpression":{"baseExpression":{"id":1034,"name":"hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":996,"src":"23749:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":1037,"indexExpression":{"id":1036,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"23756:9:1","subExpression":{"id":1035,"name":"hashPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1008,"src":"23756:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"23749:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":1038,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"Conditional","src":"23707:59:1","trueExpression":{"baseExpression":{"id":1030,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":954,"src":"23729:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":1033,"indexExpression":{"id":1032,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"23736:9:1","subExpression":{"id":1031,"name":"leafPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1004,"src":"23736:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"23729:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"23695:71:1"},{"assignments":[1041],"declarations":[{"constant":false,"id":1041,"mutability":"mutable","name":"b","nameLocation":"23788:1:1","nodeType":"VariableDeclaration","scope":1073,"src":"23780:9:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":1040,"name":"bytes32","nodeType":"ElementaryTypeName","src":"23780:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"id":1063,"initialValue":{"condition":{"baseExpression":{"id":1042,"name":"proofFlags","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":951,"src":"23792:10:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_calldata_ptr","typeString":"bool[] calldata"}},"id":1044,"indexExpression":{"id":1043,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1016,"src":"23803:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"23792:13:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseExpression":{"baseExpression":{"id":1058,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":948,"src":"23904:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},"id":1061,"indexExpression":{"id":1060,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"23910:10:1","subExpression":{"id":1059,"name":"proofPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1012,"src":"23910:8:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"23904:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":1062,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"Conditional","src":"23792:129:1","trueExpression":{"components":[{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":1047,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":1045,"name":"leafPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1004,"src":"23825:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"id":1046,"name":"leavesLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":970,"src":"23835:9:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"23825:19:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseExpression":{"baseExpression":{"id":1052,"name":"hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":996,"src":"23867:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":1055,"indexExpression":{"id":1054,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"23874:9:1","subExpression":{"id":1053,"name":"hashPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1008,"src":"23874:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"23867:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":1056,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"Conditional","src":"23825:59:1","trueExpression":{"baseExpression":{"id":1048,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":954,"src":"23847:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":1051,"indexExpression":{"id":1050,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"23854:9:1","subExpression":{"id":1049,"name":"leafPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1004,"src":"23854:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"23847:17:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"id":1057,"isConstant":false,"isInlineArray":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"TupleExpression","src":"23824:61:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"23780:141:1"},{"expression":{"id":1071,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"baseExpression":{"id":1064,"name":"hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":996,"src":"23935:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":1066,"indexExpression":{"id":1065,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1016,"src":"23942:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"23935:9:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"id":1068,"name":"a","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1026,"src":"23954:1:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"id":1069,"name":"b","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1041,"src":"23957:1:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"id":1067,"name":"hasher","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":964,"src":"23947:6:1","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"}},"id":1070,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"23947:12:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"23935:24:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":1072,"nodeType":"ExpressionStatement","src":"23935:24:1"}]},"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":1021,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":1019,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1016,"src":"23657:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"id":1020,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":975,"src":"23661:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"23657:17:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":1074,"initializationExpression":{"assignments":[1016],"declarations":[{"constant":false,"id":1016,"mutability":"mutable","name":"i","nameLocation":"23650:1:1","nodeType":"VariableDeclaration","scope":1074,"src":"23642:9:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":1015,"name":"uint256","nodeType":"ElementaryTypeName","src":"23642:7:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":1018,"initialValue":{"hexValue":"30","id":1017,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"23654:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"23642:13:1"},"loopExpression":{"expression":{"id":1023,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"23676:3:1","subExpression":{"id":1022,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1016,"src":"23676:1:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":1024,"nodeType":"ExpressionStatement","src":"23676:3:1"},"nodeType":"ForStatement","src":"23637:333:1"},{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":1077,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":1075,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":975,"src":"23984:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"hexValue":"30","id":1076,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"24000:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"23984:17:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseBody":{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":1097,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":1095,"name":"leavesLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":970,"src":"24225:9:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"hexValue":"30","id":1096,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"24237:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"24225:13:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseBody":{"id":1107,"nodeType":"Block","src":"24287:40:1","statements":[{"expression":{"baseExpression":{"id":1103,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":948,"src":"24308:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},"id":1105,"indexExpression":{"hexValue":"30","id":1104,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"24314:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"24308:8:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":968,"id":1106,"nodeType":"Return","src":"24301:15:1"}]},"id":1108,"nodeType":"IfStatement","src":"24221:106:1","trueBody":{"id":1102,"nodeType":"Block","src":"24240:41:1","statements":[{"expression":{"baseExpression":{"id":1098,"name":"leaves","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":954,"src":"24261:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":1100,"indexExpression":{"hexValue":"30","id":1099,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"24268:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"24261:9:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":968,"id":1101,"nodeType":"Return","src":"24254:16:1"}]}},"id":1109,"nodeType":"IfStatement","src":"23980:347:1","trueBody":{"id":1094,"nodeType":"Block","src":"24003:212:1","statements":[{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":1081,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":1078,"name":"proofPos","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1012,"src":"24021:8:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"!=","rightExpression":{"expression":{"id":1079,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":948,"src":"24033:5:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},"id":1080,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"24039:6:1","memberName":"length","nodeType":"MemberAccess","src":"24033:12:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"24021:24:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":1086,"nodeType":"IfStatement","src":"24017:100:1","trueBody":{"id":1085,"nodeType":"Block","src":"24047:70:1","statements":[{"errorCall":{"arguments":[],"expression":{"argumentTypes":[],"id":1082,"name":"MerkleProofInvalidMultiproof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":47,"src":"24072:28:1","typeDescriptions":{"typeIdentifier":"t_function_error_pure$__$returns$__$","typeString":"function () pure"}},"id":1083,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"24072:30:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":1084,"nodeType":"RevertStatement","src":"24065:37:1"}]}},{"id":1093,"nodeType":"UncheckedBlock","src":"24130:75:1","statements":[{"expression":{"baseExpression":{"id":1087,"name":"hashes","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":996,"src":"24165:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[] memory"}},"id":1091,"indexExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":1090,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":1088,"name":"proofFlagsLen","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":975,"src":"24172:13:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"-","rightExpression":{"hexValue":"31","id":1089,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"24188:1:1","typeDescriptions":{"typeIdentifier":"t_rational_1_by_1","typeString":"int_const 1"},"value":"1"},"src":"24172:17:1","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"24165:25:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":968,"id":1092,"nodeType":"Return","src":"24158:32:1"}]}]}}]},"documentation":{"id":945,"nodeType":"StructuredDocumentation","src":"20893:1099:1","text":" @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n respectively.\n This version handles multiproofs in calldata with a custom hashing function.\n CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n validating the leaves elsewhere."},"id":1111,"implemented":true,"kind":"function","modifiers":[],"name":"processMultiProofCalldata","nameLocation":"22006:25:1","nodeType":"FunctionDefinition","parameters":{"id":965,"nodeType":"ParameterList","parameters":[{"constant":false,"id":948,"mutability":"mutable","name":"proof","nameLocation":"22060:5:1","nodeType":"VariableDeclaration","scope":1111,"src":"22041:24:1","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":946,"name":"bytes32","nodeType":"ElementaryTypeName","src":"22041:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":947,"nodeType":"ArrayTypeName","src":"22041:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":951,"mutability":"mutable","name":"proofFlags","nameLocation":"22091:10:1","nodeType":"VariableDeclaration","scope":1111,"src":"22075:26:1","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_calldata_ptr","typeString":"bool[]"},"typeName":{"baseType":{"id":949,"name":"bool","nodeType":"ElementaryTypeName","src":"22075:4:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":950,"nodeType":"ArrayTypeName","src":"22075:6:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_storage_ptr","typeString":"bool[]"}},"visibility":"internal"},{"constant":false,"id":954,"mutability":"mutable","name":"leaves","nameLocation":"22128:6:1","nodeType":"VariableDeclaration","scope":1111,"src":"22111:23:1","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":952,"name":"bytes32","nodeType":"ElementaryTypeName","src":"22111:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":953,"nodeType":"ArrayTypeName","src":"22111:9:1","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":964,"mutability":"mutable","name":"hasher","nameLocation":"22194:6:1","nodeType":"VariableDeclaration","scope":1111,"src":"22144:56:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"},"typeName":{"id":963,"nodeType":"FunctionTypeName","parameterTypes":{"id":959,"nodeType":"ParameterList","parameters":[{"constant":false,"id":956,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":963,"src":"22153:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":955,"name":"bytes32","nodeType":"ElementaryTypeName","src":"22153:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":958,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":963,"src":"22162:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":957,"name":"bytes32","nodeType":"ElementaryTypeName","src":"22162:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"22152:18:1"},"returnParameterTypes":{"id":962,"nodeType":"ParameterList","parameters":[{"constant":false,"id":961,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":963,"src":"22185:7:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":960,"name":"bytes32","nodeType":"ElementaryTypeName","src":"22185:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"22184:9:1"},"src":"22144:56:1","stateMutability":"view","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$_t_bytes32_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32) view returns (bytes32)"},"visibility":"internal"},"visibility":"internal"}],"src":"22031:175:1"},"returnParameters":{"id":968,"nodeType":"ParameterList","parameters":[{"constant":false,"id":967,"mutability":"mutable","name":"merkleRoot","nameLocation":"22238:10:1","nodeType":"VariableDeclaration","scope":1111,"src":"22230:18:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":966,"name":"bytes32","nodeType":"ElementaryTypeName","src":"22230:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"22229:20:1"},"scope":1112,"src":"21997:2336:1","stateMutability":"view","virtual":false,"visibility":"internal"}],"scope":1113,"src":"1353:22982:1","usedErrors":[47],"usedEvents":[]}],"src":"206:24130:1"},"id":1},"contracts/Scrabble.sol":{"ast":{"absolutePath":"contracts/Scrabble.sol","exportedSymbols":{"Hashes":[39],"MerkleProof":[1112],"Scrabble":[1154]},"id":1155,"license":"MIT","nodeType":"SourceUnit","nodes":[{"id":1114,"literals":["solidity","^","0.8",".20"],"nodeType":"PragmaDirective","src":"32:24:2"},{"absolutePath":"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol","file":"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol","id":1115,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":1155,"sourceUnit":1113,"src":"58:68:2","symbolAliases":[],"unitAlias":""},{"abstract":false,"baseContracts":[],"canonicalName":"Scrabble","contractDependencies":[],"contractKind":"contract","fullyImplemented":true,"id":1154,"linearizedBaseContracts":[1154],"name":"Scrabble","nameLocation":"137:8:2","nodeType":"ContractDefinition","nodes":[{"constant":false,"functionSelector":"2eb4a7ab","id":1117,"mutability":"mutable","name":"merkleRoot","nameLocation":"165:10:2","nodeType":"VariableDeclaration","scope":1154,"src":"150:25:2","stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":1116,"name":"bytes32","nodeType":"ElementaryTypeName","src":"150:7:2","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"public"},{"body":{"id":1124,"nodeType":"Block","src":"194:160:2","statements":[{"expression":{"id":1122,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":1120,"name":"merkleRoot","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1117,"src":"270:10:2","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"hexValue":"307830303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030","id":1121,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"283:66:2","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0x0000000000000000000000000000000000000000000000000000000000000000"},"src":"270:79:2","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":1123,"nodeType":"ExpressionStatement","src":"270:79:2"}]},"id":1125,"implemented":true,"kind":"constructor","modifiers":[],"name":"","nameLocation":"-1:-1:-1","nodeType":"FunctionDefinition","parameters":{"id":1118,"nodeType":"ParameterList","parameters":[],"src":"191:2:2"},"returnParameters":{"id":1119,"nodeType":"ParameterList","parameters":[],"src":"194:0:2"},"scope":1154,"src":"180:174:2","stateMutability":"nonpayable","virtual":false,"visibility":"public"},{"body":{"id":1134,"nodeType":"Block","src":"411:35:2","statements":[{"expression":{"id":1132,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":1130,"name":"merkleRoot","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1117,"src":"417:10:2","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"id":1131,"name":"_merkleRoot","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1127,"src":"430:11:2","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"417:24:2","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":1133,"nodeType":"ExpressionStatement","src":"417:24:2"}]},"functionSelector":"7cb64759","id":1135,"implemented":true,"kind":"function","modifiers":[],"name":"setMerkleRoot","nameLocation":"367:13:2","nodeType":"FunctionDefinition","parameters":{"id":1128,"nodeType":"ParameterList","parameters":[{"constant":false,"id":1127,"mutability":"mutable","name":"_merkleRoot","nameLocation":"389:11:2","nodeType":"VariableDeclaration","scope":1135,"src":"381:19:2","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":1126,"name":"bytes32","nodeType":"ElementaryTypeName","src":"381:7:2","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"380:21:2"},"returnParameters":{"id":1129,"nodeType":"ParameterList","parameters":[],"src":"411:0:2"},"scope":1154,"src":"358:88:2","stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"body":{"id":1152,"nodeType":"Block","src":"539:61:2","statements":[{"expression":{"arguments":[{"id":1147,"name":"proof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1140,"src":"571:5:2","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"}},{"id":1148,"name":"merkleRoot","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1117,"src":"578:10:2","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"id":1149,"name":"leaf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1137,"src":"590:4:2","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[] calldata"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"expression":{"id":1145,"name":"MerkleProof","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1112,"src":"552:11:2","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_MerkleProof_$1112_$","typeString":"type(library MerkleProof)"}},"id":1146,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"564:6:2","memberName":"verify","nodeType":"MemberAccess","referencedDeclaration":68,"src":"552:18:2","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_array$_t_bytes32_$dyn_memory_ptr_$_t_bytes32_$_t_bytes32_$returns$_t_bool_$","typeString":"function (bytes32[] memory,bytes32,bytes32) pure returns (bool)"}},"id":1150,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"552:43:2","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"functionReturnParameters":1144,"id":1151,"nodeType":"Return","src":"545:50:2"}]},"functionSelector":"eb78a11f","id":1153,"implemented":true,"kind":"function","modifiers":[],"name":"verifyWord","nameLocation":"459:10:2","nodeType":"FunctionDefinition","parameters":{"id":1141,"nodeType":"ParameterList","parameters":[{"constant":false,"id":1137,"mutability":"mutable","name":"leaf","nameLocation":"478:4:2","nodeType":"VariableDeclaration","scope":1153,"src":"470:12:2","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":1136,"name":"bytes32","nodeType":"ElementaryTypeName","src":"470:7:2","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":1140,"mutability":"mutable","name":"proof","nameLocation":"503:5:2","nodeType":"VariableDeclaration","scope":1153,"src":"484:24:2","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_calldata_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":1138,"name":"bytes32","nodeType":"ElementaryTypeName","src":"484:7:2","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":1139,"nodeType":"ArrayTypeName","src":"484:9:2","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"}],"src":"469:40:2"},"returnParameters":{"id":1144,"nodeType":"ParameterList","parameters":[{"constant":false,"id":1143,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":1153,"src":"533:4:2","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":1142,"name":"bool","nodeType":"ElementaryTypeName","src":"533:4:2","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"532:6:2"},"scope":1154,"src":"450:150:2","stateMutability":"view","virtual":false,"visibility":"external"}],"scope":1155,"src":"128:474:2","usedErrors":[],"usedEvents":[]}],"src":"32:570:2"},"id":2}},"contracts":{"@openzeppelin/contracts/utils/cryptography/Hashes.sol":{"Hashes":{"abi":[],"devdoc":{"details":"Library of standard hash functions. _Available since v5.1._","kind":"dev","methods":{},"version":1},"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"60808060405234601757603a9081601d823930815050f35b600080fdfe600080fdfea26469706673582212207e189687b434b882ea680a73d5d514d796c7b122f190808b4708e1b57e8abc4464736f6c63430008140033","opcodes":"PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH1 0x17 JUMPI PUSH1 0x3A SWAP1 DUP2 PUSH1 0x1D DUP3 CODECOPY ADDRESS DUP2 POP POP RETURN JUMPDEST PUSH1 0x0 DUP1 REVERT INVALID PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 PUSH31 0x189687B434B882EA680A73D5D514D796C7B122F190808B4708E1B57E8ABC44 PUSH5 0x736F6C6343 STOP ADDMOD EQ STOP CALLER ","sourceMap":"221:811:0:-:0;;;;;;;;;;;;;;;;;;;;;"},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"600080fdfea26469706673582212207e189687b434b882ea680a73d5d514d796c7b122f190808b4708e1b57e8abc4464736f6c63430008140033","opcodes":"PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 PUSH31 0x189687B434B882EA680A73D5D514D796C7B122F190808B4708E1B57E8ABC44 PUSH5 0x736F6C6343 STOP ADDMOD EQ STOP CALLER ","sourceMap":"221:811:0:-:0;;"},"gasEstimates":{"creation":{"codeDepositCost":"11600","executionCost":"infinite","totalCost":"infinite"},"internal":{"commutativeKeccak256(bytes32,bytes32)":"infinite","efficientKeccak256(bytes32,bytes32)":"infinite"}},"methodIdentifiers":{}},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Library of standard hash functions. _Available since v5.1._\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"@openzeppelin/contracts/utils/cryptography/Hashes.sol\":\"Hashes\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/utils/cryptography/Hashes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/Hashes.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library of standard hash functions.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Hashes {\\n    /**\\n     * @dev Commutative Keccak256 hash of a sorted pair of bytes32. Frequently used when working with merkle proofs.\\n     *\\n     * NOTE: Equivalent to the `standardNodeHash` in our https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n     */\\n    function commutativeKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32) {\\n        return a < b ? efficientKeccak256(a, b) : efficientKeccak256(b, a);\\n    }\\n\\n    /**\\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\\n     */\\n    function efficientKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8cbd338f083224b4b6f0ff42cbda641a0a6c31ffcdca197452b97fe4d0918269\",\"license\":\"MIT\"}},\"version\":1}","storageLayout":{"storage":[],"types":null},"userdoc":{"kind":"user","methods":{},"version":1}}},"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol":{"MerkleProof":{"abi":[{"inputs":[],"name":"MerkleProofInvalidMultiproof","type":"error"}],"devdoc":{"details":"These functions deal with verification of Merkle Tree proofs. The tree and the proofs can be generated using our https://github.com/OpenZeppelin/merkle-tree[JavaScript library]. You will find a quickstart guide in the readme. WARNING: You should avoid using leaf values that are 64 bytes long prior to hashing, or use a hash function other than keccak256 for hashing leaves. This is because the concatenation of a sorted pair of internal nodes in the Merkle tree could be reinterpreted as a leaf value. OpenZeppelin's JavaScript library generates Merkle trees that are safe against this attack out of the box. IMPORTANT: Consider memory side-effects when using custom hashing functions that access memory in an unsafe way. NOTE: This library supports proof verification for merkle trees built using custom _commutative_ hashing functions (i.e. `H(a, b) == H(b, a)`). Proving leaf inclusion in trees built using non-commutative hashing functions requires additional logic that is not supported by this library.","errors":{"MerkleProofInvalidMultiproof()":[{"details":"The multiproof provided is not valid."}]},"kind":"dev","methods":{},"version":1},"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"60808060405234601757603a9081601d823930815050f35b600080fdfe600080fdfea26469706673582212209d6068b9c9ffacc6f8fa3c876dbd5b34ab5e45b10d270f82205922431e8869d064736f6c63430008140033","opcodes":"PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH1 0x17 JUMPI PUSH1 0x3A SWAP1 DUP2 PUSH1 0x1D DUP3 CODECOPY ADDRESS DUP2 POP POP RETURN JUMPDEST PUSH1 0x0 DUP1 REVERT INVALID PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 SWAP14 PUSH1 0x68 0xB9 0xC9 SELFDESTRUCT 0xAC 0xC6 0xF8 STATICCALL EXTCODECOPY DUP8 PUSH14 0xBD5B34AB5E45B10D270F82205922 NUMBER 0x1E DUP9 PUSH10 0xD064736F6C6343000814 STOP CALLER ","sourceMap":"1353:22982:1:-:0;;;;;;;;;;;;;;;;;;;;;"},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"600080fdfea26469706673582212209d6068b9c9ffacc6f8fa3c876dbd5b34ab5e45b10d270f82205922431e8869d064736f6c63430008140033","opcodes":"PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 SWAP14 PUSH1 0x68 0xB9 0xC9 SELFDESTRUCT 0xAC 0xC6 0xF8 STATICCALL EXTCODECOPY DUP8 PUSH14 0xBD5B34AB5E45B10D270F82205922 NUMBER 0x1E DUP9 PUSH10 0xD064736F6C6343000814 STOP CALLER ","sourceMap":"1353:22982:1:-:0;;"},"gasEstimates":{"creation":{"codeDepositCost":"11600","executionCost":"infinite","totalCost":"infinite"},"internal":{"multiProofVerify(bytes32[] memory,bool[] memory,bytes32,bytes32[] memory)":"infinite","multiProofVerify(bytes32[] memory,bool[] memory,bytes32,bytes32[] memory,function (bytes32,bytes32) view returns (bytes32))":"infinite","multiProofVerifyCalldata(bytes32[] calldata,bool[] calldata,bytes32,bytes32[] memory)":"infinite","multiProofVerifyCalldata(bytes32[] calldata,bool[] calldata,bytes32,bytes32[] memory,function (bytes32,bytes32) view returns (bytes32))":"infinite","processMultiProof(bytes32[] memory,bool[] memory,bytes32[] memory)":"infinite","processMultiProof(bytes32[] memory,bool[] memory,bytes32[] memory,function (bytes32,bytes32) view returns (bytes32))":"infinite","processMultiProofCalldata(bytes32[] calldata,bool[] calldata,bytes32[] memory)":"infinite","processMultiProofCalldata(bytes32[] calldata,bool[] calldata,bytes32[] memory,function (bytes32,bytes32) view returns (bytes32))":"infinite","processProof(bytes32[] memory,bytes32)":"infinite","processProof(bytes32[] memory,bytes32,function (bytes32,bytes32) view returns (bytes32))":"infinite","processProofCalldata(bytes32[] calldata,bytes32)":"infinite","processProofCalldata(bytes32[] calldata,bytes32,function (bytes32,bytes32) view returns (bytes32))":"infinite","verify(bytes32[] memory,bytes32,bytes32)":"infinite","verify(bytes32[] memory,bytes32,bytes32,function (bytes32,bytes32) view returns (bytes32))":"infinite","verifyCalldata(bytes32[] calldata,bytes32,bytes32)":"infinite","verifyCalldata(bytes32[] calldata,bytes32,bytes32,function (bytes32,bytes32) view returns (bytes32))":"infinite"}},"methodIdentifiers":{}},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MerkleProofInvalidMultiproof\",\"type\":\"error\"}],\"devdoc\":{\"details\":\"These functions deal with verification of Merkle Tree proofs. The tree and the proofs can be generated using our https://github.com/OpenZeppelin/merkle-tree[JavaScript library]. You will find a quickstart guide in the readme. WARNING: You should avoid using leaf values that are 64 bytes long prior to hashing, or use a hash function other than keccak256 for hashing leaves. This is because the concatenation of a sorted pair of internal nodes in the Merkle tree could be reinterpreted as a leaf value. OpenZeppelin's JavaScript library generates Merkle trees that are safe against this attack out of the box. IMPORTANT: Consider memory side-effects when using custom hashing functions that access memory in an unsafe way. NOTE: This library supports proof verification for merkle trees built using custom _commutative_ hashing functions (i.e. `H(a, b) == H(b, a)`). Proving leaf inclusion in trees built using non-commutative hashing functions requires additional logic that is not supported by this library.\",\"errors\":{\"MerkleProofInvalidMultiproof()\":[{\"details\":\"The multiproof provided is not valid.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\":\"MerkleProof\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/utils/cryptography/Hashes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/Hashes.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library of standard hash functions.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Hashes {\\n    /**\\n     * @dev Commutative Keccak256 hash of a sorted pair of bytes32. Frequently used when working with merkle proofs.\\n     *\\n     * NOTE: Equivalent to the `standardNodeHash` in our https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n     */\\n    function commutativeKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32) {\\n        return a < b ? efficientKeccak256(a, b) : efficientKeccak256(b, a);\\n    }\\n\\n    /**\\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\\n     */\\n    function efficientKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8cbd338f083224b4b6f0ff42cbda641a0a6c31ffcdca197452b97fe4d0918269\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/MerkleProof.sol)\\n// This file was procedurally generated from scripts/generate/templates/MerkleProof.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {Hashes} from \\\"./Hashes.sol\\\";\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the Merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\\n * against this attack out of the box.\\n *\\n * IMPORTANT: Consider memory side-effects when using custom hashing functions\\n * that access memory in an unsafe way.\\n *\\n * NOTE: This library supports proof verification for merkle trees built using\\n * custom _commutative_ hashing functions (i.e. `H(a, b) == H(b, a)`). Proving\\n * leaf inclusion in trees built using non-commutative hashing functions requires\\n * additional logic that is not supported by this library.\\n */\\nlibrary MerkleProof {\\n    /**\\n     *@dev The multiproof provided is not valid.\\n     */\\n    error MerkleProofInvalidMultiproof();\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in memory with the default hashing function.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leaves & pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in memory with the default hashing function.\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in memory with a custom hashing function.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bool) {\\n        return processProof(proof, leaf, hasher) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leaves & pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in memory with a custom hashing function.\\n     */\\n    function processProof(\\n        bytes32[] memory proof,\\n        bytes32 leaf,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = hasher(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in calldata with the default hashing function.\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leaves & pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in calldata with the default hashing function.\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in calldata with a custom hashing function.\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bool) {\\n        return processProofCalldata(proof, leaf, hasher) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leaves & pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in calldata with a custom hashing function.\\n     */\\n    function processProofCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 leaf,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = hasher(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * This version handles multiproofs in memory with the default hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\\n     * The `leaves` must be validated independently. See {processMultiProof}.\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * This version handles multiproofs in memory with the default hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\\n     * validating the leaves elsewhere.\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofFlagsLen = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\\n        }\\n\\n        if (proofFlagsLen > 0) {\\n            if (proofPos != proof.length) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[proofFlagsLen - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * This version handles multiproofs in memory with a custom hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\\n     * The `leaves` must be validated independently. See {processMultiProof}.\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves, hasher) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * This version handles multiproofs in memory with a custom hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\\n     * validating the leaves elsewhere.\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofFlagsLen = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = hasher(a, b);\\n        }\\n\\n        if (proofFlagsLen > 0) {\\n            if (proofPos != proof.length) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[proofFlagsLen - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * This version handles multiproofs in calldata with the default hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\\n     * The `leaves` must be validated independently. See {processMultiProofCalldata}.\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * This version handles multiproofs in calldata with the default hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\\n     * validating the leaves elsewhere.\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofFlagsLen = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\\n        }\\n\\n        if (proofFlagsLen > 0) {\\n            if (proofPos != proof.length) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[proofFlagsLen - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * This version handles multiproofs in calldata with a custom hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\\n     * The `leaves` must be validated independently. See {processMultiProofCalldata}.\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves, hasher) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * This version handles multiproofs in calldata with a custom hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\\n     * validating the leaves elsewhere.\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofFlagsLen = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = hasher(a, b);\\n        }\\n\\n        if (proofFlagsLen > 0) {\\n            if (proofPos != proof.length) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[proofFlagsLen - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x36a0c409c437a753cac9b92b75f93b0fbe92803bf2c8ff1517e54b247f166134\",\"license\":\"MIT\"}},\"version\":1}","storageLayout":{"storage":[],"types":null},"userdoc":{"kind":"user","methods":{},"version":1}}},"contracts/Scrabble.sol":{"Scrabble":{"abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"merkleRoot","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_merkleRoot","type":"bytes32"}],"name":"setMerkleRoot","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"leaf","type":"bytes32"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"verifyWord","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"devdoc":{"kind":"dev","methods":{},"version":1},"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"6080806040523461001a57600080556101ce90816100208239f35b600080fdfe608060408181526004918236101561001657600080fd5b600090813560e01c9081632eb4a7ab1461017e575080637cb64759146101615763eb78a11f1461004557600080fd5b3461015e578160031936011261015e5760249267ffffffffffffffff92843584811161015a573660238201121561015a5780830135908582116101565760059180831b90888284010190368211610152578754865190999093603f01601f191684019081118482101761014057865282526020928901838084015b838310610130575050505084359286935b82518510156101255784821b8301840151908181101561011857885283528487205b93600019811461010657600101936100d1565b634e487b7160e01b8852601187528988fd5b90885283528487206100f3565b839089875191148152f35b82358152918101918591016100c0565b634e487b7160e01b8952604188528a89fd5b8780fd5b8480fd5b8380fd5b80fd5b50823461017a57602036600319011261017a5735815580f35b5080fd5b90503461017a578160031936011261017a57602091548152f3fea2646970667358221220720fbc4cb72c9daedb27be87b127c1dcf9e3a33b67bf2c6158e857a2d0fbbe6164736f6c63430008140033","opcodes":"PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH2 0x1A JUMPI PUSH1 0x0 DUP1 SSTORE PUSH2 0x1CE SWAP1 DUP2 PUSH2 0x20 DUP3 CODECOPY RETURN JUMPDEST PUSH1 0x0 DUP1 REVERT INVALID PUSH1 0x80 PUSH1 0x40 DUP2 DUP2 MSTORE PUSH1 0x4 SWAP2 DUP3 CALLDATASIZE LT ISZERO PUSH2 0x16 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 SWAP1 DUP2 CALLDATALOAD PUSH1 0xE0 SHR SWAP1 DUP2 PUSH4 0x2EB4A7AB EQ PUSH2 0x17E JUMPI POP DUP1 PUSH4 0x7CB64759 EQ PUSH2 0x161 JUMPI PUSH4 0xEB78A11F EQ PUSH2 0x45 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE PUSH2 0x15E JUMPI DUP2 PUSH1 0x3 NOT CALLDATASIZE ADD SLT PUSH2 0x15E JUMPI PUSH1 0x24 SWAP3 PUSH8 0xFFFFFFFFFFFFFFFF SWAP3 DUP5 CALLDATALOAD DUP5 DUP2 GT PUSH2 0x15A JUMPI CALLDATASIZE PUSH1 0x23 DUP3 ADD SLT ISZERO PUSH2 0x15A JUMPI DUP1 DUP4 ADD CALLDATALOAD SWAP1 DUP6 DUP3 GT PUSH2 0x156 JUMPI PUSH1 0x5 SWAP2 DUP1 DUP4 SHL SWAP1 DUP9 DUP3 DUP5 ADD ADD SWAP1 CALLDATASIZE DUP3 GT PUSH2 0x152 JUMPI DUP8 SLOAD DUP7 MLOAD SWAP1 SWAP10 SWAP1 SWAP4 PUSH1 0x3F ADD PUSH1 0x1F NOT AND DUP5 ADD SWAP1 DUP2 GT DUP5 DUP3 LT OR PUSH2 0x140 JUMPI DUP7 MSTORE DUP3 MSTORE PUSH1 0x20 SWAP3 DUP10 ADD DUP4 DUP1 DUP5 ADD JUMPDEST DUP4 DUP4 LT PUSH2 0x130 JUMPI POP POP POP POP DUP5 CALLDATALOAD SWAP3 DUP7 SWAP4 JUMPDEST DUP3 MLOAD DUP6 LT ISZERO PUSH2 0x125 JUMPI DUP5 DUP3 SHL DUP4 ADD DUP5 ADD MLOAD SWAP1 DUP2 DUP2 LT ISZERO PUSH2 0x118 JUMPI DUP9 MSTORE DUP4 MSTORE DUP5 DUP8 KECCAK256 JUMPDEST SWAP4 PUSH1 0x0 NOT DUP2 EQ PUSH2 0x106 JUMPI PUSH1 0x1 ADD SWAP4 PUSH2 0xD1 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL DUP9 MSTORE PUSH1 0x11 DUP8 MSTORE DUP10 DUP9 REVERT JUMPDEST SWAP1 DUP9 MSTORE DUP4 MSTORE DUP5 DUP8 KECCAK256 PUSH2 0xF3 JUMP JUMPDEST DUP4 SWAP1 DUP10 DUP8 MLOAD SWAP2 EQ DUP2 MSTORE RETURN JUMPDEST DUP3 CALLDATALOAD DUP2 MSTORE SWAP2 DUP2 ADD SWAP2 DUP6 SWAP2 ADD PUSH2 0xC0 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL DUP10 MSTORE PUSH1 0x41 DUP9 MSTORE DUP11 DUP10 REVERT JUMPDEST DUP8 DUP1 REVERT JUMPDEST DUP5 DUP1 REVERT JUMPDEST DUP4 DUP1 REVERT JUMPDEST DUP1 REVERT JUMPDEST POP DUP3 CALLVALUE PUSH2 0x17A JUMPI PUSH1 0x20 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0x17A JUMPI CALLDATALOAD DUP2 SSTORE DUP1 RETURN JUMPDEST POP DUP1 REVERT JUMPDEST SWAP1 POP CALLVALUE PUSH2 0x17A JUMPI DUP2 PUSH1 0x3 NOT CALLDATASIZE ADD SLT PUSH2 0x17A JUMPI PUSH1 0x20 SWAP2 SLOAD DUP2 MSTORE RETURN INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 PUSH19 0xFBC4CB72C9DAEDB27BE87B127C1DCF9E3A33B PUSH8 0xBF2C6158E857A2D0 0xFB 0xBE PUSH2 0x6473 PUSH16 0x6C634300081400330000000000000000 ","sourceMap":"128:474:2:-:0;;;;;;;283:66;128:474;;;;;;;;;;;;"},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"608060408181526004918236101561001657600080fd5b600090813560e01c9081632eb4a7ab1461017e575080637cb64759146101615763eb78a11f1461004557600080fd5b3461015e578160031936011261015e5760249267ffffffffffffffff92843584811161015a573660238201121561015a5780830135908582116101565760059180831b90888284010190368211610152578754865190999093603f01601f191684019081118482101761014057865282526020928901838084015b838310610130575050505084359286935b82518510156101255784821b8301840151908181101561011857885283528487205b93600019811461010657600101936100d1565b634e487b7160e01b8852601187528988fd5b90885283528487206100f3565b839089875191148152f35b82358152918101918591016100c0565b634e487b7160e01b8952604188528a89fd5b8780fd5b8480fd5b8380fd5b80fd5b50823461017a57602036600319011261017a5735815580f35b5080fd5b90503461017a578160031936011261017a57602091548152f3fea2646970667358221220720fbc4cb72c9daedb27be87b127c1dcf9e3a33b67bf2c6158e857a2d0fbbe6164736f6c63430008140033","opcodes":"PUSH1 0x80 PUSH1 0x40 DUP2 DUP2 MSTORE PUSH1 0x4 SWAP2 DUP3 CALLDATASIZE LT ISZERO PUSH2 0x16 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 SWAP1 DUP2 CALLDATALOAD PUSH1 0xE0 SHR SWAP1 DUP2 PUSH4 0x2EB4A7AB EQ PUSH2 0x17E JUMPI POP DUP1 PUSH4 0x7CB64759 EQ PUSH2 0x161 JUMPI PUSH4 0xEB78A11F EQ PUSH2 0x45 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE PUSH2 0x15E JUMPI DUP2 PUSH1 0x3 NOT CALLDATASIZE ADD SLT PUSH2 0x15E JUMPI PUSH1 0x24 SWAP3 PUSH8 0xFFFFFFFFFFFFFFFF SWAP3 DUP5 CALLDATALOAD DUP5 DUP2 GT PUSH2 0x15A JUMPI CALLDATASIZE PUSH1 0x23 DUP3 ADD SLT ISZERO PUSH2 0x15A JUMPI DUP1 DUP4 ADD CALLDATALOAD SWAP1 DUP6 DUP3 GT PUSH2 0x156 JUMPI PUSH1 0x5 SWAP2 DUP1 DUP4 SHL SWAP1 DUP9 DUP3 DUP5 ADD ADD SWAP1 CALLDATASIZE DUP3 GT PUSH2 0x152 JUMPI DUP8 SLOAD DUP7 MLOAD SWAP1 SWAP10 SWAP1 SWAP4 PUSH1 0x3F ADD PUSH1 0x1F NOT AND DUP5 ADD SWAP1 DUP2 GT DUP5 DUP3 LT OR PUSH2 0x140 JUMPI DUP7 MSTORE DUP3 MSTORE PUSH1 0x20 SWAP3 DUP10 ADD DUP4 DUP1 DUP5 ADD JUMPDEST DUP4 DUP4 LT PUSH2 0x130 JUMPI POP POP POP POP DUP5 CALLDATALOAD SWAP3 DUP7 SWAP4 JUMPDEST DUP3 MLOAD DUP6 LT ISZERO PUSH2 0x125 JUMPI DUP5 DUP3 SHL DUP4 ADD DUP5 ADD MLOAD SWAP1 DUP2 DUP2 LT ISZERO PUSH2 0x118 JUMPI DUP9 MSTORE DUP4 MSTORE DUP5 DUP8 KECCAK256 JUMPDEST SWAP4 PUSH1 0x0 NOT DUP2 EQ PUSH2 0x106 JUMPI PUSH1 0x1 ADD SWAP4 PUSH2 0xD1 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL DUP9 MSTORE PUSH1 0x11 DUP8 MSTORE DUP10 DUP9 REVERT JUMPDEST SWAP1 DUP9 MSTORE DUP4 MSTORE DUP5 DUP8 KECCAK256 PUSH2 0xF3 JUMP JUMPDEST DUP4 SWAP1 DUP10 DUP8 MLOAD SWAP2 EQ DUP2 MSTORE RETURN JUMPDEST DUP3 CALLDATALOAD DUP2 MSTORE SWAP2 DUP2 ADD SWAP2 DUP6 SWAP2 ADD PUSH2 0xC0 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL DUP10 MSTORE PUSH1 0x41 DUP9 MSTORE DUP11 DUP10 REVERT JUMPDEST DUP8 DUP1 REVERT JUMPDEST DUP5 DUP1 REVERT JUMPDEST DUP4 DUP1 REVERT JUMPDEST DUP1 REVERT JUMPDEST POP DUP3 CALLVALUE PUSH2 0x17A JUMPI PUSH1 0x20 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0x17A JUMPI CALLDATALOAD DUP2 SSTORE DUP1 RETURN JUMPDEST POP DUP1 REVERT JUMPDEST SWAP1 POP CALLVALUE PUSH2 0x17A JUMPI DUP2 PUSH1 0x3 NOT CALLDATASIZE ADD SLT PUSH2 0x17A JUMPI PUSH1 0x20 SWAP2 SLOAD DUP2 MSTORE RETURN INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 PUSH19 0xFBC4CB72C9DAEDB27BE87B127C1DCF9E3A33B PUSH8 0xBF2C6158E857A2D0 0xFB 0xBE PUSH2 0x6473 PUSH16 0x6C634300081400330000000000000000 ","sourceMap":"128:474:2:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;128:474:2;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2601:13:1;;2596:134;2634:3;128:474:2;;2616:16:1;;;;;128:474:2;;;;;;;;;605:5:0;;;;;;889:135;;;;;;;605:59;2634:3:1;-1:-1:-1;;128:474:2;;;;;;2601:13:1;;;128:474:2;-1:-1:-1;;;128:474:2;;;;;;;;605:59:0;889:135;;;;;;;;605:59;;2616:16:1;;;;;128:474:2;2016:33:1;;128:474:2;;;;;;;;;;;;;;;;;;-1:-1:-1;;;128:474:2;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;128:474:2;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"},"gasEstimates":{"creation":{"codeDepositCost":"92400","executionCost":"5153","totalCost":"97553"},"external":{"merkleRoot()":"2267","setMerkleRoot(bytes32)":"22282","verifyWord(bytes32,bytes32[])":"infinite"}},"methodIdentifiers":{"merkleRoot()":"2eb4a7ab","setMerkleRoot(bytes32)":"7cb64759","verifyWord(bytes32,bytes32[])":"eb78a11f"}},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyWord\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Scrabble.sol\":\"Scrabble\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/utils/cryptography/Hashes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/Hashes.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library of standard hash functions.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Hashes {\\n    /**\\n     * @dev Commutative Keccak256 hash of a sorted pair of bytes32. Frequently used when working with merkle proofs.\\n     *\\n     * NOTE: Equivalent to the `standardNodeHash` in our https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n     */\\n    function commutativeKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32) {\\n        return a < b ? efficientKeccak256(a, b) : efficientKeccak256(b, a);\\n    }\\n\\n    /**\\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\\n     */\\n    function efficientKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8cbd338f083224b4b6f0ff42cbda641a0a6c31ffcdca197452b97fe4d0918269\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/MerkleProof.sol)\\n// This file was procedurally generated from scripts/generate/templates/MerkleProof.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {Hashes} from \\\"./Hashes.sol\\\";\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the Merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\\n * against this attack out of the box.\\n *\\n * IMPORTANT: Consider memory side-effects when using custom hashing functions\\n * that access memory in an unsafe way.\\n *\\n * NOTE: This library supports proof verification for merkle trees built using\\n * custom _commutative_ hashing functions (i.e. `H(a, b) == H(b, a)`). Proving\\n * leaf inclusion in trees built using non-commutative hashing functions requires\\n * additional logic that is not supported by this library.\\n */\\nlibrary MerkleProof {\\n    /**\\n     *@dev The multiproof provided is not valid.\\n     */\\n    error MerkleProofInvalidMultiproof();\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in memory with the default hashing function.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leaves & pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in memory with the default hashing function.\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in memory with a custom hashing function.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bool) {\\n        return processProof(proof, leaf, hasher) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leaves & pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in memory with a custom hashing function.\\n     */\\n    function processProof(\\n        bytes32[] memory proof,\\n        bytes32 leaf,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = hasher(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in calldata with the default hashing function.\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leaves & pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in calldata with the default hashing function.\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in calldata with a custom hashing function.\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bool) {\\n        return processProofCalldata(proof, leaf, hasher) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leaves & pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in calldata with a custom hashing function.\\n     */\\n    function processProofCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 leaf,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = hasher(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * This version handles multiproofs in memory with the default hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\\n     * The `leaves` must be validated independently. See {processMultiProof}.\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * This version handles multiproofs in memory with the default hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\\n     * validating the leaves elsewhere.\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofFlagsLen = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\\n        }\\n\\n        if (proofFlagsLen > 0) {\\n            if (proofPos != proof.length) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[proofFlagsLen - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * This version handles multiproofs in memory with a custom hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\\n     * The `leaves` must be validated independently. See {processMultiProof}.\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves, hasher) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * This version handles multiproofs in memory with a custom hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\\n     * validating the leaves elsewhere.\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofFlagsLen = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = hasher(a, b);\\n        }\\n\\n        if (proofFlagsLen > 0) {\\n            if (proofPos != proof.length) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[proofFlagsLen - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * This version handles multiproofs in calldata with the default hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\\n     * The `leaves` must be validated independently. See {processMultiProofCalldata}.\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * This version handles multiproofs in calldata with the default hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\\n     * validating the leaves elsewhere.\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofFlagsLen = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\\n        }\\n\\n        if (proofFlagsLen > 0) {\\n            if (proofPos != proof.length) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[proofFlagsLen - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * This version handles multiproofs in calldata with a custom hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\\n     * The `leaves` must be validated independently. See {processMultiProofCalldata}.\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves, hasher) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * This version handles multiproofs in calldata with a custom hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\\n     * validating the leaves elsewhere.\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofFlagsLen = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = hasher(a, b);\\n        }\\n\\n        if (proofFlagsLen > 0) {\\n            if (proofPos != proof.length) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[proofFlagsLen - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x36a0c409c437a753cac9b92b75f93b0fbe92803bf2c8ff1517e54b247f166134\",\"license\":\"MIT\"},\"contracts/Scrabble.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\ncontract Scrabble {\\n  bytes32 public merkleRoot;\\n\\n  constructor() {\\n    // Initial merkleRoot can be set here or later with setMerkleRoot\\n    merkleRoot = 0x0000000000000000000000000000000000000000000000000000000000000000;\\n  }\\n\\n  function setMerkleRoot(bytes32 _merkleRoot) external {\\n    merkleRoot = _merkleRoot;\\n  }\\n\\n  function verifyWord(bytes32 leaf, bytes32[] calldata proof) external view returns (bool) {\\n    return MerkleProof.verify(proof, merkleRoot, leaf);\\n  }\\n}\",\"keccak256\":\"0xc8773d4c16d2ab83ad62e9a326202f7c1a5c9e54f7e663a8ddc99c58ce455355\",\"license\":\"MIT\"}},\"version\":1}","storageLayout":{"storage":[{"astId":1117,"contract":"contracts/Scrabble.sol:Scrabble","label":"merkleRoot","offset":0,"slot":"0","type":"t_bytes32"}],"types":{"t_bytes32":{"encoding":"inplace","label":"bytes32","numberOfBytes":"32"}}},"userdoc":{"kind":"user","methods":{},"version":1}}}}}}